{
  "version": 3,
  "sources": ["../src/calcMandelbrotOutline.ts", "../src/calcnPlot.ts", "../src/index.ts"],
  "sourcesContent": ["import { iterationDepth } from \"src\"\r\n\r\nexport let boundaryPoints: {real: number, imag:number}[] = []\r\nexport function calcMandelbrotOutline(){\r\n\r\n    boundaryPoints=[]\r\n    \r\n    // start from the well known left tip of the mandelbrot-set\r\n    const startPoint = {real: -2, imag:0}\r\n    \r\n    //step slightly out of the mandelbrotset at samplingRate/2 step\r\n    let directionVector = {real: -1, imag: 0}\r\n    const samplingRate = 1/Math.pow(iterationDepth,3)\r\n    const sampleRotation = Math.PI/8\r\n    let actualPoint = add(startPoint, scale(directionVector, samplingRate/2))\r\n    \r\n    console.log(\"samplingRate: \"+samplingRate+\" at iterationDepth: \"+iterationDepth)\r\n    \r\n    boundaryPoints.push(actualPoint)\r\n    \r\n    // then move upwards from here on\r\n    directionVector = {real: 0, imag: 1}\r\n\r\n    //move around the whole mandelbroz\r\n    while (actualPoint.real < 0){\r\n    //for (let i = 0; i  < 1500; i++) {\r\n       \r\n        // test if actualPoint + directionVector is inside the Mandelbrot\r\n        // cover the case, where we pierce into the set\r\n        if(mandelbrot(add(actualPoint, scale(directionVector, samplingRate)))){\r\n                while (mandelbrot(add(actualPoint, scale(directionVector, samplingRate)))){\r\n                    // adjust by rotating the directionvector away from the set\r\n                    \r\n                    directionVector = rotate(directionVector, sampleRotation)\r\n                }\r\n            actualPoint = add(actualPoint, scale(directionVector, samplingRate))\r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    \r\n        // cover the case, where we do not pierce into the set\r\n        if(!mandelbrot(add(actualPoint, scale(directionVector, samplingRate)))){\r\n            while(!mandelbrot(add(actualPoint, scale(directionVector, samplingRate))))    {\r\n                //rotate the other way around\r\n                directionVector = rotate(directionVector, -sampleRotation)\r\n            }\r\n            // then rotate back to get out of the set again\r\n            directionVector = rotate(directionVector, sampleRotation)\r\n            actualPoint = add(actualPoint, scale(directionVector, samplingRate))\r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    }\r\n    console.log(\"boundaryPoints.length: \"+boundaryPoints.length)\r\n   \r\n}\r\n\r\nfunction rotate(vector: {real: number, imag: number}, rotationAngle: number): {real: number, imag: number}{\r\n    const originLength = Math.sqrt(Math.pow(vector.real,2)+ Math.pow(vector.imag,2))\r\n    const originAngle = Math.atan2(vector.imag, vector.real)\r\n    const destinationAngle = originAngle + rotationAngle\r\n    const rotatedVector = scale({real: Math.cos(destinationAngle), imag: Math.sin(destinationAngle)}, originLength)\r\n    return rotatedVector\r\n}\r\n\r\nfunction scale(vector: {real: number, imag: number}, amount: number): {real: number, imag: number}{\r\n    return {real: vector.real * amount, imag: vector.imag * amount}\r\n}\r\n\r\nfunction add(v1: {real: number, imag: number}, v2: {real: number, imag: number}): {real: number, imag: number}{\r\n    return {real: v1.real + v2.real, imag: v1.imag + v2.imag}\r\n}\r\n\r\nfunction mandelbrot(c: {real: number, imag: number}): boolean{\r\n    let z = { real: c.real, imag: c.imag };\r\n    let iterations = 0;\r\n    while((iterations < iterationDepth) && (z.real * z.real + z.imag * z.imag) <= 4){\r\n        let realTemp  = z.real * z.real - z.imag * z.imag + c.real\r\n        z.imag = 2 * z.real * z.imag + c.imag\r\n        z.real = realTemp\r\n        \r\n        iterations ++\r\n        if(iterations == iterationDepth){\r\n            return true\r\n        }\r\n        \r\n    }\r\n    return false\r\n}", "import { overviewSvg, xMax, xMin, yMax, yMin, iterationDepth, svgWidth, svgHeight} from \"src\";\r\n\r\nexport class Mandelbrot{\r\n    \r\n    width:number = overviewSvg.getBBox().width;\r\n    height:number = overviewSvg.getBBox().height;\r\n   \r\n    boundaryPoints: {real:number, imag: number}[]  = []\r\n\r\n    // Skalierungsfunktionen von Canvas-Koordinaten auf komplexe Zahlenebene\r\n    scaleX(x: number) { return xMin + (x / this.width) * (xMax - xMin); }\r\n    scaleY(y: number) { return yMin + (y / this.height) * (yMax - yMin); }\r\n\r\n    // Mandelbrot-Iteration\r\n    mandelbrot(viewPortCoordinate: {real: number, imag: number}) {\r\n        //const c = {real: this.scaleX(viewPortCoordinate.x), imag: this.scaleY(viewPortCoordinate.y)}\r\n        const c = viewPortCoordinate\r\n        let z = { real: 0, imag: 0 };\r\n        let iterations = 0;\r\n        \r\n        while (iterations < iterationDepth && ( z.real * z.real + z.imag * z.imag <= 4)) {\r\n            let realTemp = z.real * z.real - z.imag * z.imag + c.real;\r\n            z.imag = 2 * z.real * z.imag + c.imag;\r\n            z.real = realTemp;\r\n            iterations++;\r\n            if (iterations == iterationDepth && z.real * z.real + z.imag * z.imag > 3.5 && z.real * z.real + z.imag * z.imag <= 4.5){\r\n                return viewPortCoordinate\r\n            }\r\n        }\r\n    }\r\n\r\n    // Grenzlinie berechnen und plotten\r\n    drawCloud() {\r\n        /*\r\n        // Selektiere alle Elemente mit der Klasse \"cloudDot\"\r\n        const cloudDots = document.querySelectorAll('cloudDot');\r\n        // Iteriere \u00FCber die NodeList und entferne jedes Element\r\n        cloudDots.forEach(dot => dot.remove());\r\n*/\r\n        this.boundaryPoints = [];\r\n        const sampleWidth = (xMax - xMin)/svgWidth\r\n        const sampleHeight = (yMax - yMin)/svgHeight\r\n        for (let x = xMin; x < xMax; x += sampleWidth) {\r\n            \r\n            for (let y = yMin; y < yMax; y += sampleHeight) {\r\n                \r\n                const c = { real: x, imag: y };\r\n                const borderPoint = this.mandelbrot(c);\r\n\r\n                // Nur Punkte, die genau nach der Iterationstiefe die Grenze \u00FCberschreiten, werden aufgenommen\r\n                if(borderPoint)\r\n                    this.boundaryPoints.push(borderPoint)\r\n                \r\n            }\r\n        }\r\n        \r\n        //reference object to insert the dots before\r\n        const outlinePath = document.getElementById(\"outlinePath\")\r\n        \r\n        const oldCloudPath = document.getElementById(\"cloudPath\")\r\n        oldCloudPath?.parentNode?.removeChild(oldCloudPath)\r\n        \r\n        const cloudPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\n        cloudPath.setAttribute(\"fill\", \"none\")\r\n        cloudPath.setAttribute(\"stroke\", \"darkblue\")\r\n        cloudPath.setAttribute(\"stroke-width\", `${sampleHeight}`)\r\n        cloudPath.setAttribute(\"id\", \"cloudPath\")\r\n        //cloudPath.setAttribute(\"vector-effect\", `non-scaling-stroke`)\r\n        overviewSvg.insertBefore(cloudPath, outlinePath)\r\n        \r\n    \r\n        let pathData = `M${this.boundaryPoints[0].real} ${this.boundaryPoints[0].imag} v${sampleWidth}`\r\n        \r\n        for(let i = 1; i<this.boundaryPoints.length; i++){\r\n            pathData += `M ${this.boundaryPoints[i].real}${this.boundaryPoints[i].imag} v${sampleWidth}`\r\n        }\r\n    \r\n        cloudPath.setAttribute(\"d\", `${pathData}`)\r\n        \r\n/*      //example for a cloud out of circle Elements\r\n        this.boundaryPoints.forEach(point => {\r\n            \r\n            const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\")\r\n            circle.setAttribute(\"cx\", `${point.real}`)\r\n            circle.setAttribute(\"cy\", `${point.imag}`)\r\n            circle.setAttribute(\"r\", `${sampleWidth}`)\r\n            circle.setAttribute(\"fill\", \"lightgrey\")\r\n            circle.setAttribute(\"class\", \"cloudDot\")\r\n\r\n\r\n            svg.insertBefore(circle, outlinePath[0]);\r\n        });\r\n*/\r\n    }\r\n    \r\n}    ", "\r\nimport { boundaryPoints, calcMandelbrotOutline } from \"./calcMandelbrotOutline.js\";\r\nimport { Mandelbrot } from \"./calcnPlot.js\";\r\n\r\nconst wrapper = document.getElementById(\"wrapper\")\r\nexport const svgWidth = 600\r\nexport const svgHeight = 480\r\nlet width = 2.5\r\nlet height = width\r\nexport let iterationDepth = 5;  // Iterationstiefe\r\nexport let xMin = -2, xMax = xMin + width\r\nexport let yMin = -1.2, yMax = yMin + height\r\n\r\nconst headline: HTMLHeadElement = document.createElement(\"h1\")\r\nheadline.innerHTML = `Mandelbrot-Grenzlinie bei Iterationstiefe i = ${iterationDepth}`\r\n\r\nexport const overviewSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\noverviewSvg.setAttribute(\"id\", \"mandelbrotSvg\")\r\noverviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\noverviewSvg.setAttribute(\"width\", `${svgWidth}px`)\r\noverviewSvg.setAttribute(\"height\", `${svgHeight}px`)\r\n\r\nconst outlinePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\noverviewSvg.appendChild(outlinePath)\r\n\r\nconst iterationsSliderLabel = document.createElement(\"label\")\r\niterationsSliderLabel.setAttribute(\"for\", \"iterationsSlider\")\r\niterationsSliderLabel.innerHTML = \"iterations: \"\r\nconst iterationsSlider = document.createElement(\"input\")\r\niterationsSlider.id = \"iterationsSlider\"\r\niterationsSlider.type = \"range\"\r\niterationsSlider.min = \"2\"\r\niterationsSlider.max = \"13\"\r\niterationsSlider.step = \"1\"\r\niterationsSlider.value = `${iterationDepth}`\r\n\r\nconst xMinSliderLabel = document.createElement(\"label\")\r\nxMinSliderLabel.setAttribute(\"for\", \"xMinSlider\")\r\nxMinSliderLabel.innerHTML = \"x-move:\"\r\nconst xMinSlider = document.createElement(\"input\")\r\nxMinSlider.id = \"xMinSlider\"\r\nxMinSlider.type = \"range\"\r\nxMinSlider.min = \"-6\"\r\nxMinSlider.max = \"2.0\"\r\nxMinSlider.step = \".1\"\r\nxMinSlider.value = `${xMin}`\r\n\r\nconst yMinSliderLabel = document.createElement(\"label\")\r\nyMinSliderLabel.setAttribute(\"for\", \"yMinSlider\")\r\nyMinSliderLabel.innerHTML = \"y-move:\"\r\nconst yMinSlider = document.createElement(\"input\")\r\nyMinSlider.id = \"yMinslider\"\r\nyMinSlider.type = \"range\"\r\nyMinSlider.min =\"-6\"\r\nyMinSlider.max = \"2\"\r\nyMinSlider.step = \".1\"\r\nyMinSlider.value = `${yMin}`\r\n\r\nconst zoomSliderLabel = document.createElement(\"label\")\r\nzoomSliderLabel.setAttribute(\"for\", \"zoomSlider\")\r\nzoomSliderLabel.innerHTML = \"zoom: \"\r\nconst zoomSlider = document.createElement(\"input\")\r\nzoomSlider.id = \"zoomSlider\"\r\nzoomSlider.type = \"range\"\r\nzoomSlider.min = \".1\"\r\nzoomSlider.max = \"4\"\r\nzoomSlider.step = \".1\"\r\nzoomSlider.value = `${width}`\r\n\r\nwrapper?.appendChild(headline)\r\nwrapper?.appendChild(iterationsSliderLabel)\r\nwrapper?.appendChild(iterationsSlider)\r\nwrapper?.appendChild(xMinSliderLabel)\r\nwrapper?.appendChild(xMinSlider)\r\nwrapper?.appendChild(yMinSliderLabel)\r\nwrapper?.appendChild(yMinSlider)\r\nwrapper?.appendChild(zoomSliderLabel)\r\nwrapper?.appendChild(zoomSlider)\r\nwrapper?.appendChild(overviewSvg)\r\n\r\n\r\n// calc and plot MandelbrotOutline\r\ncalcMandelbrotOutline()\r\ndrawLines()\r\n\r\n\r\n// Draw a Mandelbrot cloud for reference\r\nconst mandelbrot = new Mandelbrot();\r\nmandelbrot.drawCloud();\r\n\r\niterationsSlider.addEventListener(\"input\", function(event){\r\n    iterationDepth = parseInt(iterationsSlider.value)\r\n    headline.innerHTML = `Mandelbrot-Grenzlinie bei Iterationstiefe i = ${iterationDepth}`\r\n    mandelbrot.drawCloud()\r\n    calcMandelbrotOutline()\r\n    drawLines()\r\n})\r\n\r\nxMinSlider.addEventListener(\"input\", function(){\r\n    xMin = parseFloat(xMinSlider.value)\r\n    xMax = xMin + width\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\nyMinSlider.addEventListener(\"input\", function(){\r\n    yMin = parseFloat(yMinSlider.value)\r\n    yMax = yMin + height\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\nzoomSlider.addEventListener(\"input\", function(){\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width = parseFloat(zoomSlider.value)\r\n    height = width\r\n    xMin -= (width - oldWidth )/2\r\n    xMax = xMin + width\r\n    \r\n    yMin -=(height - oldHeight)/2\r\n    yMax = yMin + height\r\n\r\n    overviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n\r\n    xMinSlider.step = (parseFloat(zoomSlider.value)/40).toString()\r\n    yMinSlider.step = (parseFloat(zoomSlider.value)/40).toString()\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\noverviewSvg.addEventListener(\"mouseenter\", () => {\r\n    console.log(\"mouse entered\");\r\n})\r\n\r\nfunction mapToCanvas(point: {real: number, imag: number}): {x: number, y: number}{\r\n    const x = ((point.real - xMin) / (xMax - xMin)) * svgWidth; // Bereich real -2 bis 2 auf 0 bis canvasWidth skalieren\r\n    const y =   ((point.imag - yMin) / (yMax - yMin)) * svgHeight; // Bereich imag -2 bis 2 auf 0 bis canvasHeight skalieren (invertiert f\u00FCr Canvas-Koordinaten)\r\n    return { x, y };\r\n}\r\n\r\nfunction drawLines(){\r\n    if(boundaryPoints.length < 2){\r\n        console.warn(\"Not enough points to draw lines\")\r\n        return;\r\n    }\r\n    outlinePath.innerHTML = \"\"\r\n    let pathData = `M${boundaryPoints[0].real} ${boundaryPoints[0].imag}`\r\n    for(let i = 1; i<boundaryPoints.length; i++){\r\n        pathData += `L ${boundaryPoints[i].real} ${boundaryPoints[i].imag}`\r\n    }\r\n    outlinePath.setAttribute(\"id\", \"outlinePath\")\r\n    outlinePath.setAttribute(\"fill\", \"none\")\r\n    outlinePath.setAttribute(\"stroke\", \"black\")\r\n    outlinePath.setAttribute(\"stroke-width\", \".5 px\")\r\n    outlinePath.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n    outlinePath.setAttribute(\"d\", `${pathData}`)\r\n}\r\n"],
  "mappings": "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",
  "names": ["outlinePath", "mandelbrot"]
}
