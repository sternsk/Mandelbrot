{
  "version": 3,
  "sources": ["../src/calcMandelbrotOutline.ts", "../src/calcnPlot.ts", "../src/extrapolate.ts", "../src/library.ts", "../src/index.ts"],
  "sourcesContent": ["import { iterationDepth, spectraSvg } from \"src\"\r\n\r\nexport let boundaryPoints: {real: number, imag:number}[] = []\r\n\r\nlet allSteps: {startPoint: {\r\n                    real: number, \r\n                    imag: number}, \r\n                endPoint: {\r\n                    real: number, \r\n                    imag: number}, \r\n                color: string}[]= \r\n                []\r\n\r\nlet done = false\r\nconst actualSample = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\")\r\n\r\nexport function calcMandelbrotOutline(){\r\n    //initialize spectraSvg\r\n    done = false\r\n    allSteps = []\r\n    spectraSvg.innerHTML = \"\"\r\n\r\n    const begin = Date.now()\r\n    \r\n    actualSample.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n    actualSample.setAttribute(\"stroke-width\", \"1px\")    \r\n    actualSample.setAttribute(\"id\", \"actualSample\")\r\n    spectraSvg.appendChild(actualSample)\r\n\r\n    let duration: number\r\n\r\n    boundaryPoints=[]\r\n    \r\n    // start from the well known left tip of the mandelbrot-set\r\n    const startPoint = {real: -2, imag:0}\r\n    \r\n    //step slightly out of the mandelbrotset at samplingRate/2 step\r\n    let directionVector = {real: -1, imag: 0}\r\n    const sampleLength = 1/Math.pow(iterationDepth,3)\r\n    const sampleAngle = Math.PI/8\r\n    let actualPoint = add(startPoint, scale(directionVector, sampleLength/2))\r\n    \r\n    console.log(\"samplingRate: \"+sampleLength+\" at iterationDepth: \"+iterationDepth)\r\n    \r\n    boundaryPoints.push(actualPoint)\r\n    \r\n    // then move upwards from here on\r\n    directionVector = {real: 0, imag: 1}\r\n\r\n    //move around for a reasonable amount\r\n    while (actualPoint.imag >= 0){\r\n    //for (let i = 0; i  < 1500; i++) {\r\n       \r\n        // test if actualPoint + directionVector is inside the Mandelbrot\r\n        // cover the case, where we pierce into the set\r\n        if(mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n                /*\r\n                setTimeout in Schleifen:\r\n\r\nsetTimeout f\u00FChrt den angegebenen Callback asynchron aus. Dadurch wird der Inhalt von setTimeout nicht blockierend ausgef\u00FChrt, sondern in die Warteschlange (Event Loop) gestellt. Das kann zu unerwartetem Verhalten f\u00FChren, insbesondere wenn die Schleife schnell durchl\u00E4uft.\r\nDa die Schleife nicht wartet, bis der setTimeout-Callback ausgef\u00FChrt wurde, k\u00F6nnen Werte von Variablen wie directionVector oder actualPoint zwischenzeitlich weiter ver\u00E4ndert werden, was zu falschen Ergebnissen f\u00FChren kann.\r\n         */\r\n            while (mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n                \r\n                const endPoint = add(actualPoint, scale(directionVector, sampleLength))\r\n                allSteps.push({startPoint: actualPoint, endPoint, color: \"brown\"})\r\n                \r\n                // adjust by rotating the directionvector away from the set\r\n                directionVector = rotate(directionVector, sampleAngle)\r\n                \r\n                \r\n                /*\r\n                actualSample.setAttribute(\"x1\", `${actualPoint.real}`)\r\n                actualSample.setAttribute(\"y1\", `${actualPoint.imag}`)\r\n                actualSample.setAttribute(\"x2\", `${endPoint.real}`)\r\n                actualSample.setAttribute(\"y2\", `${endPoint.imag}`)\r\n                actualSample.setAttribute(\"stroke\", \"brown\")\r\n            */\r\n            \r\n                    \r\n            }\r\n            const endpoint = add(actualPoint, scale(directionVector, sampleLength))\r\n            allSteps.push({startPoint: actualPoint, endPoint: endpoint, color: \"red\"})\r\n            actualPoint = endpoint\r\n\r\n\r\n            /*\r\n            actualSample.setAttribute(\"x1\", `${actualPoint.real}`)\r\n            actualSample.setAttribute(\"y1\", `${actualPoint.imag}`)\r\n            actualSample.setAttribute(\"x2\", `${add(actualPoint, scale(directionVector, sampleLength)).real}`)\r\n            actualSample.setAttribute(\"y2\", `${add(actualPoint, scale(directionVector, sampleLength)).imag}`)\r\n            actualSample.setAttribute(\"stroke\", \"black\")\r\n            const calculatedSample = actualSample.cloneNode(false) as SVGLineElement\r\n            calculatedSample.setAttribute(\"id\", \"calculatedSample\")\r\n            spectraSvg.appendChild(calculatedSample)\r\n*/\r\n            \r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    \r\n        // cover the case, where we do not pierce into the set\r\n        if(!mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n            while(!mandelbrot(add(actualPoint, scale(directionVector, sampleLength))))    {\r\n                const endPoint = add(actualPoint, scale(directionVector, sampleLength))\r\n                allSteps.push({startPoint: actualPoint, endPoint, color: \"blue\"})\r\n                \r\n                //rotate the other way around\r\n                directionVector = rotate(directionVector, -sampleAngle)\r\n            }\r\n            // then rotate back to get out of the set again\r\n            directionVector = rotate(directionVector, sampleAngle)\r\n\r\n            const endpoint = add(actualPoint, scale(directionVector, sampleLength))\r\n            allSteps.push({startPoint: actualPoint, endPoint: endpoint, color: \"red\"})\r\n\r\n            actualPoint = endpoint\r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    done = true\r\n    animateOutline()\r\n    }\r\n\r\n    \r\n        \r\n    console.log(\"boundaryPoints.length: \"+boundaryPoints.length)\r\n    duration = Date.now() - begin\r\n    console.log(`sampling mb-outline in ${duration} ms`)\r\n}\r\n\r\nlet currentAnimation: NodeJS.Timeout | null = null; // Speichert das aktuelle Intervall\r\n\r\nfunction animateOutline(){\r\n    if(done){\r\n        let i = 0\r\n        if (currentAnimation !== null) {\r\n            clearInterval(currentAnimation);\r\n            currentAnimation = null;\r\n            console.log(\"Vorherige Animation abgebrochen\");\r\n        }\r\n        \r\n        currentAnimation = setInterval(() =>{\r\n            \r\n            if (i >= allSteps.length || !done) {\r\n                clearInterval(currentAnimation!); // Intervall beenden\r\n                console.log(\"intervall cleared\")\r\n                return;\r\n            }\r\n\r\n            const startPoint = allSteps[i].startPoint\r\n            const endPoint = allSteps[i].endPoint\r\n            const color = allSteps[i].color\r\n            \r\n            actualSample.setAttribute(\"x1\", `${startPoint.real}`)\r\n            actualSample.setAttribute(\"y1\", `${startPoint.imag}`)\r\n            actualSample.setAttribute(\"x2\", `${endPoint.real}`)\r\n            actualSample.setAttribute(\"y2\", `${endPoint.imag}`)\r\n            actualSample.setAttribute(\"stroke\", `${color}`)\r\n\r\n            // spectraSvg.setAttribute(\"viewBox\", `${startPoint.real - .05} \r\n            //                                     ${startPoint.imag  - .05} \r\n            //                                     ${endPoint.real - startPoint.real + .1}\r\n            //                                     ${endPoint.imag - startPoint.imag + .1}`)\r\n\r\n            const calculatedSample = actualSample.cloneNode(false) as SVGLineElement\r\n            calculatedSample.setAttribute(\"id\", \"calculatedSample\")\r\n            spectraSvg.appendChild(calculatedSample)\r\n\r\n            \r\n            i++\r\n        }, 100)\r\n    }\r\n}\r\n\r\nfunction rotate(vector: {real: number, imag: number}, rotationAngle: number): {real: number, imag: number}{\r\n    const originLength = Math.sqrt(Math.pow(vector.real,2)+ Math.pow(vector.imag,2))\r\n    const originAngle = Math.atan2(vector.imag, vector.real)\r\n    const destinationAngle = originAngle + rotationAngle\r\n    const rotatedVector = scale({real: Math.cos(destinationAngle), imag: Math.sin(destinationAngle)}, originLength)\r\n    return rotatedVector\r\n}\r\n\r\nfunction scale(vector: {real: number, imag: number}, amount: number): {real: number, imag: number}{\r\n    return {real: vector.real * amount, imag: vector.imag * amount}\r\n}\r\n\r\nfunction add(v1: {real: number, imag: number}, v2: {real: number, imag: number}): {real: number, imag: number}{\r\n    return {real: v1.real + v2.real, imag: v1.imag + v2.imag}\r\n}\r\n\r\nfunction mandelbrot(c: {real: number, imag: number}): boolean{\r\n    let z = { real: c.real, imag: c.imag };\r\n    let iterations = 0;\r\n    while((iterations < iterationDepth) && (z.real * z.real + z.imag * z.imag) <= 4){\r\n        let realTemp  = z.real * z.real - z.imag * z.imag + c.real\r\n        z.imag = 2 * z.real * z.imag + c.imag\r\n        z.real = realTemp\r\n        \r\n        iterations ++\r\n        if(iterations == iterationDepth){\r\n            return true\r\n        }\r\n        \r\n    }\r\n    return false\r\n}", "import { overviewSvg, xMax, xMin, yMax, yMin, iterationDepth, overviewSvgWidth, overviewSvgHeight} from \"src\";\r\n\r\nexport class Mandelbrot{\r\n    \r\n    width:number = overviewSvg.getBBox().width;\r\n    height:number = overviewSvg.getBBox().height;\r\n   \r\n    boundaryPoints: {real:number, imag: number}[]  = []\r\n\r\n    // Skalierungsfunktionen von Canvas-Koordinaten auf komplexe Zahlenebene\r\n    scaleX(x: number) { return xMin + (x / this.width) * (xMax - xMin); }\r\n    scaleY(y: number) { return yMin + (y / this.height) * (yMax - yMin); }\r\n\r\n    // Mandelbrot-Iteration\r\n    mandelbrot(viewPortCoordinate: {real: number, imag: number}) {\r\n        //const c = {real: this.scaleX(viewPortCoordinate.x), imag: this.scaleY(viewPortCoordinate.y)}\r\n        const c = viewPortCoordinate\r\n        let z = { real: 0, imag: 0 };\r\n        let iterations = 0;\r\n        \r\n        while (iterations < iterationDepth && ( z.real * z.real + z.imag * z.imag <= 4)) {\r\n            let realTemp = z.real * z.real - z.imag * z.imag + c.real;\r\n            z.imag = 2 * z.real * z.imag + c.imag;\r\n            z.real = realTemp;\r\n            iterations++;\r\n            if (iterations == iterationDepth && z.real * z.real + z.imag * z.imag > 3.5 && z.real * z.real + z.imag * z.imag <= 4.5){\r\n                return viewPortCoordinate\r\n            }\r\n        }\r\n    }\r\n\r\n    // Grenzlinie berechnen und plotten\r\n    drawCloud() {\r\n        /*\r\n        // Selektiere alle Elemente mit der Klasse \"cloudDot\"\r\n        const cloudDots = document.querySelectorAll('cloudDot');\r\n        // Iteriere \u00FCber die NodeList und entferne jedes Element\r\n        cloudDots.forEach(dot => dot.remove());\r\n*/\r\n        this.boundaryPoints = [];\r\n        const sampleWidth = (xMax - xMin)/overviewSvgWidth\r\n        const sampleHeight = (yMax - yMin)/overviewSvgHeight\r\n        for (let x = xMin; x < xMax; x += sampleWidth) {\r\n            \r\n            for (let y = yMin; y < yMax; y += sampleHeight) {\r\n                \r\n                const c = { real: x, imag: y };\r\n                const borderPoint = this.mandelbrot(c);\r\n\r\n                // Nur Punkte, die genau nach der Iterationstiefe die Grenze \u00FCberschreiten, werden aufgenommen\r\n                if(borderPoint)\r\n                    this.boundaryPoints.push(borderPoint)\r\n                \r\n            }\r\n        }\r\n        \r\n        //reference object to insert the dots before\r\n        const outlinePath = document.getElementById(\"outlinePath\")\r\n        \r\n        const oldCloudPath = document.getElementById(\"cloudPath\")\r\n        oldCloudPath?.parentNode?.removeChild(oldCloudPath)\r\n        \r\n        const cloudPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\n        cloudPath.setAttribute(\"fill\", \"none\")\r\n        cloudPath.setAttribute(\"stroke\", \"darkblue\")\r\n        cloudPath.setAttribute(\"stroke-width\", `${sampleHeight}`)\r\n        cloudPath.setAttribute(\"id\", \"cloudPath\")\r\n        //cloudPath.setAttribute(\"vector-effect\", `non-scaling-stroke`)\r\n        overviewSvg.insertBefore(cloudPath, outlinePath)\r\n        \r\n    \r\n        let pathData = `M${this.boundaryPoints[0].real} ${this.boundaryPoints[0].imag} v${sampleWidth}`\r\n        \r\n        for(let i = 1; i<this.boundaryPoints.length; i++){\r\n            pathData += `M ${this.boundaryPoints[i].real}${this.boundaryPoints[i].imag} v${sampleWidth}`\r\n        }\r\n    \r\n        cloudPath.setAttribute(\"d\", `${pathData}`)\r\n        \r\n/*      //example for a cloud out of circle Elements\r\n        this.boundaryPoints.forEach(point => {\r\n            \r\n            const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\")\r\n            circle.setAttribute(\"cx\", `${point.real}`)\r\n            circle.setAttribute(\"cy\", `${point.imag}`)\r\n            circle.setAttribute(\"r\", `${sampleWidth}`)\r\n            circle.setAttribute(\"fill\", \"lightgrey\")\r\n            circle.setAttribute(\"class\", \"cloudDot\")\r\n\r\n\r\n            svg.insertBefore(circle, outlinePath[0]);\r\n        });\r\n*/\r\n    }\r\n    \r\n}    ", "export function extrapolateReal(points: {real: number, imag: number}[]): {i: number, real: number}[]{\r\n\r\n    const restructuredPoints = points.map((point, index) =>({\r\n        i: index,\r\n        real: point.real\r\n    }))\r\n    \r\n    \r\n    return restructuredPoints\r\n}\r\n\r\nexport function extrapolateImag(points: {real: number, imag: number}[]): {i: number, imag: number}[]{\r\n\r\n    const restructuredPoints = points.map((point, index) =>({\r\n        i: index,\r\n        imag: point.imag\r\n    }))\r\n    \r\n    return restructuredPoints\r\n}\r\n\r\nexport function extrapolate(\r\n    points: {real: number, imag: number}[], \r\n    part: \"real\" | \"imag\"\r\n): {index: number, value: number}[]{\r\n        return points.map((complex,index)=>({\r\n            index,\r\n            value: complex[part]\r\n\r\n        }))\r\n    }", "import { frequencySlider } from \"src\";\r\n\r\nlet audioContext: AudioContext | null = null;\r\nexport let oscillator: OscillatorNode | null = null;\r\n\r\n/**\r\n * Create an oscillator from a custom waveform.\r\n * @param data - Array of objects with `real` and `imag` properties defining the waveform.\r\n */\r\nexport async function createOscillatorFromWaveform(data: { real: number; imag: number }[]) {\r\n    if (!audioContext) {\r\n        audioContext = new AudioContext();\r\n    }\r\n    oscillator = audioContext.createOscillator();\r\n\r\n    // Extract real and imag values into separate arrays\r\n    const realValues = new Float32Array(data.map(point => point.real));\r\n    const imagValues = new Float32Array(data.map(point => point.imag));\r\n\r\n    // Create a PeriodicWave\r\n    const wave = audioContext.createPeriodicWave(realValues, imagValues);\r\n\r\n    // Set the waveform and connect the oscillator\r\n    oscillator.setPeriodicWave(wave);\r\n    oscillator.connect(audioContext.destination);\r\n\r\n    // Set frequency\r\n    oscillator.frequency.value = parseFloat(frequencySlider.value)\r\n\r\n    // Start the oscillator\r\n    oscillator.start();\r\n}\r\n\r\n\r\n\r\n/**\r\n * Stop the sound and release resources.\r\n */\r\nexport function stopSound() {\r\n    if (oscillator) {\r\n        oscillator.stop();\r\n        oscillator.disconnect();\r\n        oscillator = null;\r\n    }\r\n\r\n    if (audioContext) {\r\n        audioContext.close();\r\n        audioContext = null;\r\n    }\r\n}\r\n\r\nfunction normalizeWaveform(data: { index: number; value: number }[]): Float32Array {\r\n    const values = data.map((d) => d.value);\r\n    const max = Math.max(...values);\r\n    const min = Math.min(...values);\r\n    return Float32Array.from(values.map((v) => 2 * (v - min) / (max - min) - 1)); // Normierung auf [-1, 1]\r\n  }\r\n  \r\n\r\n\r\n/*\r\n\r\nFalls dein Array keine periodische Wellenform darstellt oder du es direkt ohne Interpolation abspielen m\u00F6chtest, kannst du stattdessen einen AudioBuffer verwenden. Dies erzeugt einen einzelnen Klang und ist keine kontinuierliche Schwingung:\r\nconst data = [\r\n  { index: 0, value: 0 },\r\n  { index: 1, value: 0.5 },\r\n  { index: 2, value: 1 },\r\n  { index: 3, value: 0.5 },\r\n  { index: 4, value: 0 },\r\n  { index: 5, value: -0.5 },\r\n  { index: 6, value: -1 },\r\n  { index: 7, value: -0.5 },\r\n]; // Beispiel einer Wellenform\r\n\r\ncreateOscillatorFromWaveform(data).catch((err) => console.error(err));\r\n\r\nasync function playWaveform(data: { index: number; value: number }[], sampleRate = 44100) {\r\n  const audioContext = new AudioContext();\r\n\r\n  // Normalisiere die Wellenform\r\n  const normalizedWaveform = normalizeWaveform(data);\r\n\r\n  // Erstelle einen AudioBuffer\r\n  const buffer = audioContext.createBuffer(1, normalizedWaveform.length, sampleRate);\r\n  const channelData = buffer.getChannelData(0);\r\n  channelData.set(normalizedWaveform);\r\n\r\n  // AudioBufferSourceNode erstellen\r\n  const source = audioContext.createBufferSource();\r\n  source.buffer = buffer;\r\n  source.connect(audioContext.destination);\r\n\r\n  // Abspielen\r\n  source.start();\r\n}\r\n*/", "\r\nconsole.log(\"ver 2104\")\r\n\r\nimport { boundaryPoints, calcMandelbrotOutline } from \"./calcMandelbrotOutline.js\";\r\nimport { Mandelbrot } from \"./calcnPlot.js\";\r\nimport { extrapolateReal, extrapolateImag, extrapolate } from \"./extrapolate.js\";\r\nimport { createOscillatorFromWaveform, stopSound, oscillator} from \"./library.js\";\r\n\r\n\r\nconst wrapper = document.getElementById(\"wrapper\")\r\n\r\nexport const overviewSvgWidth =480\r\nexport const overviewSvgHeight = 420\r\nlet width = 2.5\r\nlet height = width\r\nexport let iterationDepth = 4;  // Iterationstiefe\r\nexport let xMin = -2, xMax = xMin + width\r\nexport let yMin = -1.2, yMax = yMin + height\r\n\r\nconst headline: HTMLHeadElement = document.createElement(\"h1\")\r\nheadline.innerHTML = `View and oszillate the mandelbrot at depth: ${iterationDepth}`\r\n\r\nexport const overviewSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\noverviewSvg.setAttribute(\"id\", \"mandelbrotSvg\")\r\noverviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\noverviewSvg.setAttribute(\"width\", `${overviewSvgWidth}px`)\r\noverviewSvg.setAttribute(\"height\", `${overviewSvgHeight}px`)\r\n\r\nexport const spectraSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nspectraSvg.setAttribute(\"id\", \"spectraSvg\")\r\nspectraSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\nspectraSvg.setAttribute(\"width\", `${overviewSvgWidth}px`)\r\nspectraSvg.setAttribute(\"height\", `${overviewSvgHeight}px`)\r\n// if(document.documentElement.clientWidth < 1004){\r\n//     spectraSvg.style.display = \"none\"\r\n// }else{\r\n// spectraSvg.style.display = \"block\" // setting display somehow ruins the default layout\r\n// spectraSvg.style.position = \"static\"\r\n// }\r\n\r\nwindow.addEventListener(\"resize\", () =>{\r\n    if (document.documentElement.clientWidth < 1004){\r\n        spectraSvg.style.display = \"none\"\r\n    } \r\n})\r\n\r\n\r\nconst viewControlsContainer = document.createElement(\"div\")\r\nviewControlsContainer.id = \"viewControlsContainer\"\r\nviewControlsContainer.style.border = \"1px solid black\"\r\nviewControlsContainer.style.padding = \"10px\"\r\n\r\nconst viewElementsContainer = document.createElement(\"div\")\r\nviewElementsContainer.id = \"viewElementsContainer\"\r\nviewElementsContainer.style.border = \"1px solid black\"\r\nviewElementsContainer.style.padding = \"10px\"\r\n\r\nconst soundControlsContainer = document.createElement(\"div\")\r\nsoundControlsContainer.id = \"soundControlsContainer\"\r\nsoundControlsContainer.style.border = \"1px solid black\"\r\nsoundControlsContainer.style.padding = \"10px\"\r\n\r\nconst xDataSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nconst xDataSvgWidth = 200\r\nconst xDataSvgHeight = 100\r\nxDataSvg.style.marginLeft = \"5px\"\r\nxDataSvg.setAttribute(\"id\", \"xDataSvg\")\r\nxDataSvg.setAttribute(\"width\", `${xDataSvgWidth}`)\r\nxDataSvg.setAttribute(\"height\", `${xDataSvgHeight}`)\r\n/*xDataSvg.style.position = \"absolute\"\r\nxDataSvg.style.x = \"800px\"\r\nxDataSvg.style.top = \"400px\"\r\n*/\r\nconst yDataSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nconst yDataSvgWidth = 200\r\nconst yDataSvgHeight = 100\r\nyDataSvg.style.marginLeft = \"5px\"\r\nyDataSvg.setAttribute(\"id\", \"yDataSvg\")\r\nyDataSvg.setAttribute(\"width\", `${yDataSvgWidth}`)\r\nyDataSvg.setAttribute(\"height\", `${yDataSvgHeight}`)\r\n\r\nconst outlinePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\noverviewSvg.appendChild(outlinePath)\r\n\r\nconst iterationsSliderLabel = document.createElement(\"label\")\r\niterationsSliderLabel.setAttribute(\"for\", \"iterationsSlider\")\r\niterationsSliderLabel.innerHTML = \"iterations: \"\r\nconst iterationsSlider = document.createElement(\"input\")\r\niterationsSlider.id = \"iterationsSlider\"\r\niterationsSlider.type = \"range\"\r\niterationsSlider.min = \"2\"\r\niterationsSlider.max = \"15\"\r\niterationsSlider.step = \"1\"\r\niterationsSlider.value = `${iterationDepth}`\r\n\r\nconst xMinSliderLabel = document.createElement(\"label\")\r\nxMinSliderLabel.setAttribute(\"for\", \"xMinSlider\")\r\nxMinSliderLabel.innerHTML = \"x-move:\"\r\nconst xMinSlider = document.createElement(\"input\")\r\nxMinSlider.id = \"xMinSlider\"\r\nxMinSlider.type = \"range\"\r\nxMinSlider.min = \"-6\"\r\nxMinSlider.max = \"2.0\"\r\nxMinSlider.step = \".1\"\r\nxMinSlider.value = `${xMin}`\r\n\r\nconst yMinSliderLabel = document.createElement(\"label\")\r\nyMinSliderLabel.setAttribute(\"for\", \"yMinSlider\")\r\nyMinSliderLabel.innerHTML = \"y-move:\"\r\nconst yMinSlider = document.createElement(\"input\")\r\nyMinSlider.id = \"yMinslider\"\r\nyMinSlider.type = \"range\"\r\nyMinSlider.min =\"-6\"\r\nyMinSlider.max = \"2\"\r\nyMinSlider.step = \".1\"\r\nyMinSlider.value = `${yMin}`\r\n\r\nconst zoomSliderLabel = document.createElement(\"label\")\r\nzoomSliderLabel.setAttribute(\"for\", \"zoomSlider\")\r\nzoomSliderLabel.innerHTML = \"zoom: \"\r\nconst zoomSlider = document.createElement(\"input\")\r\nzoomSlider.id = \"zoomSlider\"\r\nzoomSlider.type = \"range\"\r\nzoomSlider.min = \".1\"\r\nzoomSlider.max = \"4\"\r\nzoomSlider.step = \".1\"\r\nzoomSlider.value = `${width}`\r\n\r\n\r\n\r\nconst oscillateButton = document.createElement(\"button\")\r\noscillateButton.innerHTML = \"oscillate boundary points\"\r\noscillateButton.style.width = \"200px\"\r\nlet isPlaying = false\r\noscillateButton.addEventListener(\"click\", ()=>{\r\n    if(!isPlaying){\r\n        createOscillatorFromWaveform(boundaryPoints)\r\n        oscillateButton.textContent = \"stop sound\"\r\n    }\r\n    if(isPlaying){\r\n        stopSound()\r\n        oscillateButton.textContent = \"oscillate boundary points\"\r\n    }\r\n    isPlaying = !isPlaying\r\n\r\n})\r\n\r\nconst frequencySliderLabel = document.createElement(\"label\")\r\nfrequencySliderLabel.setAttribute(\"for\", \"frequencySlider\")\r\nfrequencySliderLabel.innerHTML = \" frequency: \"\r\nexport const frequencySlider = document.createElement(\"input\")\r\nfrequencySlider.id = \"frequencySlider\"\r\nfrequencySlider.type = \"range\"\r\nfrequencySlider.min = \"1\"\r\nfrequencySlider.max = \"440\"\r\nfrequencySlider.value = \"1\"\r\n\r\nfrequencySlider.addEventListener(\"input\", (event) => {\r\n    const frequency = (event.target as HTMLInputElement).valueAsNumber;\r\n    if(oscillator)\r\n        oscillator.frequency.value = frequency; // \u00C4ndert die Frequenz in Echtzeit\r\n  });\r\n\r\n\r\nsoundControlsContainer.appendChild(oscillateButton)\r\nsoundControlsContainer.appendChild(frequencySliderLabel)\r\nsoundControlsContainer.appendChild(frequencySlider)\r\n\r\nviewControlsContainer.appendChild(iterationsSliderLabel)\r\nviewControlsContainer.appendChild(iterationsSlider)\r\nviewControlsContainer.appendChild(iterationsSlider)\r\nviewControlsContainer.appendChild(xMinSliderLabel)\r\nviewControlsContainer.appendChild(xMinSlider)\r\nviewControlsContainer.appendChild(yMinSliderLabel)\r\nviewControlsContainer.appendChild(yMinSlider)\r\nviewControlsContainer.appendChild(zoomSliderLabel)\r\nviewControlsContainer.appendChild(zoomSlider)\r\n\r\nviewElementsContainer.appendChild(overviewSvg)\r\nviewElementsContainer.appendChild(spectraSvg)\r\nviewElementsContainer.appendChild(xDataSvg)\r\nviewElementsContainer.appendChild(yDataSvg)\r\n\r\n// calc and plot MandelbrotOutline\r\ncalcMandelbrotOutline()\r\ndrawLines()\r\n\r\nlet xDataLine = drawExtrapolatedCurve(extrapolate(boundaryPoints, \"real\"))\r\nlet yDataLine = drawExtrapolatedCurve(extrapolate(boundaryPoints, \"imag\"))\r\n\r\nxDataSvg.appendChild(xDataLine)\r\nyDataSvg.appendChild(yDataLine)\r\n\r\nwrapper?.appendChild(headline)\r\nwrapper?.appendChild(soundControlsContainer)\r\nwrapper?.appendChild(viewControlsContainer)\r\nwrapper?.appendChild(viewElementsContainer)\r\n\r\n// Draw a Mandelbrot cloud for reference\r\nconst mandelbrot = new Mandelbrot();\r\nwindow.onload = () =>{\r\n    \r\n    mandelbrot.drawCloud();\r\n    \r\n}\r\n\r\niterationsSlider.addEventListener(\"input\", function(event){\r\n    iterationDepth = parseInt(iterationsSlider.value)\r\n    headline.innerHTML = `Mandelbrot-Grenzlinie bei Iterationstiefe i = ${iterationDepth}`\r\n    mandelbrot.drawCloud()\r\n    calcMandelbrotOutline()\r\n    if(isPlaying) createOscillatorFromWaveform(boundaryPoints)\r\n    drawLines()\r\n\r\n    xDataLine = drawExtrapolatedCurve(extrapolate(boundaryPoints, \"real\"))\r\n    xDataSvg.innerHTML = \"\"\r\n    xDataSvg.appendChild(xDataLine)\r\n    \r\n    yDataLine = drawExtrapolatedCurve(extrapolate(boundaryPoints, \"imag\"))\r\n    yDataSvg.innerHTML = \"\"\r\n    yDataSvg.appendChild(yDataLine)\r\n})\r\n\r\nxMinSlider.addEventListener(\"input\", function(){\r\n    xMin = parseFloat(xMinSlider.value)\r\n    xMax = xMin + width\r\n    overviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n})\r\n\r\nyMinSlider.addEventListener(\"input\", function(){\r\n    yMin = parseFloat(yMinSlider.value)\r\n    yMax = yMin + height\r\n    overviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n})\r\n\r\nzoomSlider.addEventListener(\"input\", function(){\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width = parseFloat(zoomSlider.value)\r\n    height = width\r\n    xMin -= (width - oldWidth )/2\r\n    xMax = xMin + width\r\n    \r\n    yMin -=(height - oldHeight)/2\r\n    yMax = yMin + height\r\n\r\n    overviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    xMinSlider.step = (parseFloat(zoomSlider.value)/40).toString()\r\n    yMinSlider.step = (parseFloat(zoomSlider.value)/40).toString()\r\n    zoomSlider.step = zoomSlider.min\r\n})\r\n\r\nzoomSlider.addEventListener(\"mouseup\", () =>{\r\n    mandelbrot.drawCloud()\r\n    const sliderMinAttribute =zoomSlider.getAttribute(\"min\")\r\n    let minValue\r\n    if (sliderMinAttribute){\r\n        minValue = parseFloat(sliderMinAttribute)\r\n        zoomSlider.min = `${minValue/10}`\r\n        \r\n    }\r\n})\r\n\r\noverviewSvg.addEventListener(\"mouseleave\", () => {\r\n    mousedown = false\r\n})\r\n\r\nlet xOffset: number\r\nlet yOffset: number\r\nlet mousedown = false\r\noverviewSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\n\r\noverviewSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(event);\r\n    xMin += xOffset - coords.x\r\n    yMin += yOffset - coords.y\r\n    overviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\noverviewSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\noverviewSvg.addEventListener(\"wheel\", (event) =>{\r\n    \r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width += width * 10 / event.deltaY \r\n    height = width\r\n    \r\n    xMin -= (width - oldWidth )/2\r\n    xMax = xMin + width\r\n    yMin -=(height - oldHeight)/2\r\n    yMax = yMin + height\r\n\r\n    overviewSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\nspectraSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSpectraCoords(event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\nspectraSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSpectraCoords(event);\r\n    xMin += xOffset - coords.x\r\n    yMin += yOffset - coords.y\r\n    spectraSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n})\r\nspectraSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    \r\n})\r\n\r\nspectraSvg.addEventListener(\"wheel\", (event) =>{\r\n    \r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width += width * 10 / event.deltaY \r\n    height = width\r\n    \r\n    xMin -= (width - oldWidth )/2\r\n    xMax = xMin + width\r\n    yMin -=(height - oldHeight)/2\r\n    yMax = yMin + height\r\n\r\n    spectraSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\n// Helper to get SVG coordinates\r\nfunction getSvgCoords(event: MouseEvent) {\r\n    const point = overviewSvg.createSVGPoint();\r\n    point.x = event.clientX;\r\n    point.y = event.clientY;\r\n    const svgCoords = point.matrixTransform(overviewSvg.getScreenCTM()!.inverse());\r\n    return svgCoords;\r\n}\r\n\r\nfunction getSpectraCoords(event: MouseEvent) {\r\n    const point = spectraSvg.createSVGPoint();\r\n    point.x = event.clientX;\r\n    point.y = event.clientY;\r\n    const svgCoords = point.matrixTransform(spectraSvg.getScreenCTM()!.inverse());\r\n    return svgCoords;\r\n}\r\n\r\nfunction mapToCanvas(point: {real: number, imag: number}): {x: number, y: number}{\r\n    const x = ((point.real - xMin) / (xMax - xMin)) * overviewSvgWidth; // Bereich real -2 bis 2 auf 0 bis canvasWidth skalieren\r\n    const y =   ((point.imag - yMin) / (yMax - yMin)) * overviewSvgHeight; // Bereich imag -2 bis 2 auf 0 bis canvasHeight skalieren (invertiert f\u00FCr Canvas-Koordinaten)\r\n    return { x, y };\r\n}\r\n\r\nfunction drawLines(){\r\n    if(boundaryPoints.length < 2){\r\n        console.warn(\"Not enough points to draw lines\")\r\n        return;\r\n    }\r\n    outlinePath.innerHTML = \"\"\r\n    let pathData = `M${boundaryPoints[0].real} ${boundaryPoints[0].imag}`\r\n    for(let i = 1; i<boundaryPoints.length; i++){\r\n        pathData += `L ${boundaryPoints[i].real} ${boundaryPoints[i].imag}`\r\n    }\r\n    outlinePath.setAttribute(\"id\", \"outlinePath\")\r\n    outlinePath.setAttribute(\"fill\", \"none\")\r\n    outlinePath.setAttribute(\"stroke\", \"black\")\r\n    outlinePath.setAttribute(\"stroke-width\", \".5 px\")\r\n    outlinePath.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n    outlinePath.setAttribute(\"d\", `${pathData}`)\r\n}\r\n\r\nfunction drawExtrapolatedCurve(points: {index: number, value: number}[]): SVGPathElement{\r\n    \r\n    // Skalierung f\u00FCr die X- und Y-Koordinaten basierend auf `i` und `real`-Werten\r\n    const width = xDataSvgWidth\r\n    const height = xDataSvgHeight\r\n    const xScale = width / (points.length - 1); // Breite durch Anzahl der Punkte\r\n    const yMin = Math.min(...points.map(p => p.value));\r\n    const yMax = Math.max(...points.map(p => p.value));\r\n    const yScale = height / (yMax - yMin);\r\n\r\n    // Erzeuge die \"d\"-Attribute f\u00FCr das <path>-Element\r\n    let pathData = `M 0 ${height - (points[0].value - yMin) * yScale}`;\r\n    for (let j = 1; j < points.length; j++) {\r\n        const x = j * xScale;\r\n        const y = height - (points[j].value - yMin) * yScale;\r\n        pathData += ` L ${x} ${y}`;\r\n    }\r\n    \r\n\r\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"id\", \"extrapolatedCurve\")\r\n    path.setAttribute(\"d\", pathData);\r\n    path.setAttribute(\"fill\", \"none\");\r\n    path.setAttribute(\"stroke\", \"blue\");\r\n    path.setAttribute(\"stroke-width\", \"2\");\r\n    return (path);\r\n}\r\n\r\nfunction drawExtrapolatedCurveForImagValues(points: {i: number, imag: number}[]){\r\n    \r\n    // Skalierung f\u00FCr die X- und Y-Koordinaten basierend auf `i` und `real`-Werten\r\n    const width = xDataSvgWidth\r\n    const height = xDataSvgHeight\r\n    const xScale = width / (points.length - 1); // Breite durch Anzahl der Punkte\r\n    const yMin = Math.min(...points.map(p => p.imag));\r\n    const yMax = Math.max(...points.map(p => p.imag));\r\n    const yScale = height / (yMax - yMin);\r\n\r\n    // Erzeuge die \"d\"-Attribute f\u00FCr das <path>-Element\r\n    let pathData = `M 0 ${height - (points[0].imag - yMin) * yScale}`;\r\n    for (let j = 1; j < points.length; j++) {\r\n        const x = j * xScale;\r\n        const y = height - (points[j].imag - yMin) * yScale;\r\n        pathData += ` L ${x} ${y}`;\r\n    }\r\n    const oldPath = document.getElementById(\"extrapolatedImagCurve\")\r\n    oldPath?.parentNode?.removeChild(oldPath)\r\n\r\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"id\", \"extrapolatedImagCurve\")\r\n    path.setAttribute(\"d\", pathData);\r\n    path.setAttribute(\"fill\", \"none\");\r\n    path.setAttribute(\"stroke\", \"blue\");\r\n    path.setAttribute(\"stroke-width\", \"2\");\r\n    yDataSvg.appendChild(path);\r\n}"],
  "mappings": "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",
  "names": ["outlinePath", "mandelbrot", "width", "height", "yMin", "yMax"]
}
