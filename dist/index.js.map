{
  "version": 3,
  "sources": ["../src/calcMandelbrotOutline.ts", "../src/library.ts", "../src/index.ts"],
  "sourcesContent": ["\r\nimport { Complex } from \"./library\"\r\nimport { iterationDepth } from \"src\"\r\n\r\nlet boundaryPoints: {real: number, imag:number}[] = []\r\n\r\n\r\n\r\nexport function calcMandelbrotOutline(): Complex[]{\r\n    \r\n    const begin = Date.now()\r\n    let duration: number\r\n\r\n    boundaryPoints=[]\r\n    \r\n    // start from the well known left tip of the mandelbrot-set\r\n    const startPoint = {real: -2, imag:0}\r\n    \r\n    //step slightly out of the mandelbrotset at samplingRate/2 step\r\n    let directionVector = {real: -1, imag: 0}\r\n    const sampleLength = .1/Math.pow(iterationDepth,3)\r\n    const sampleAngle = Math.PI/8\r\n    let actualPoint = add(startPoint, scale(directionVector, sampleLength/2))\r\n    \r\n    console.log(\"sampleLength: \"+sampleLength+\" at iterationDepth: \"+iterationDepth)\r\n    \r\n    boundaryPoints.push(actualPoint)\r\n    \r\n    // then move upwards from here on\r\n    directionVector = {real: 0, imag: 1}\r\n\r\n    //move around half a time\r\n    while (actualPoint.imag >= 0){\r\n    \r\n        // test if actualPoint + directionVector/2 is inside the Mandelbrot\r\n        // if(mandelbrot(add(actualPoint, scale(directionVector, sampleLength/2)))){\r\n        //     // adjust by rotating the directionvector away from the set\r\n        //     directionVector = rotate(directionVector, sampleAngle)\r\n        // }\r\n        // cover the case, where we pierce into the set\r\n        if(mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n            directionVector = rotate(directionVector, .5 * sampleAngle)\r\n                \r\n            while (mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n           \r\n                // adjust by rotating the directionvector away from the set\r\n                directionVector = rotate(directionVector, .5 * sampleAngle)\r\n                    \r\n            }\r\n            const endpoint = add(actualPoint, scale(directionVector, sampleLength))\r\n            actualPoint = endpoint\r\n            \r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n        \r\n    \r\n        // cover the case, where we do not pierce into the set\r\n        if(!mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n        // test if actualPoint + directionVector/2 is inside the Mandelbrot\r\n            if(mandelbrot(add(actualPoint, scale(directionVector, sampleLength/2)))){\r\n                // adjust by rotating the directionvector away from the set\r\n                console.log(\"actualPoint + directionVector is not, but actualPoint + directionVector/2 is inside the Mandelbrot\")\r\n                directionVector = rotate(directionVector, 2*sampleAngle)\r\n            }\r\n            while(!mandelbrot(add(actualPoint, scale(directionVector, sampleLength))))    {\r\n                \r\n                //rotate the other way around towards the set\r\n                directionVector = rotate(directionVector, -.5*sampleAngle)\r\n            }\r\n            // then rotate away from the set to get out of the set again\r\n            directionVector = rotate(directionVector, .5*sampleAngle)\r\n\r\n            const endpoint = add(actualPoint, scale(directionVector, sampleLength))\r\n\r\n            actualPoint = endpoint\r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    \r\n    }\r\n        \r\n    console.log(\"boundaryPoints.length: \"+boundaryPoints.length)\r\n    duration = Date.now() - begin\r\n    console.log(`sampling duration: ${duration} ms`)\r\n\r\n    return boundaryPoints\r\n}\r\n\r\nexport function mirrorX(samplePoints: Complex[]): Complex[]{\r\n    const arrayLength = samplePoints.length\r\n    const mirroredPoints = [...samplePoints]\r\n        for ( let index = arrayLength - 2; index >= 0; index--){\r\n            const reversedPoint = {real: samplePoints[index].real, imag: -samplePoints[index].imag}\r\n            mirroredPoints.push(reversedPoint)\r\n        }\r\n        return mirroredPoints\r\n}\r\n\r\nfunction rotate(vector: {real: number, imag: number}, rotationAngle: number): {real: number, imag: number}{\r\n    const originLength = Math.sqrt(Math.pow(vector.real,2)+ Math.pow(vector.imag,2))\r\n    const originAngle = Math.atan2(vector.imag, vector.real)\r\n    const destinationAngle = originAngle + rotationAngle\r\n    const rotatedVector = scale({real: Math.cos(destinationAngle), imag: Math.sin(destinationAngle)}, originLength)\r\n    return rotatedVector\r\n}\r\n\r\nfunction scale(vector: {real: number, imag: number}, amount: number): {real: number, imag: number}{\r\n    return {real: vector.real * amount, imag: vector.imag * amount}\r\n}\r\n\r\nfunction add(v1: {real: number, imag: number}, v2: {real: number, imag: number}): {real: number, imag: number}{\r\n    return {real: v1.real + v2.real, imag: v1.imag + v2.imag}\r\n}\r\n\r\nfunction mandelbrot(c: {real: number, imag: number}): boolean{\r\n    let z = { real: c.real, imag: c.imag };\r\n    let iterations = 0;\r\n    while((iterations < iterationDepth) && (z.real * z.real + z.imag * z.imag) <= 4){\r\n        let realTemp  = z.real * z.real - z.imag * z.imag + c.real\r\n        z.imag = 2 * z.real * z.imag + c.imag\r\n        z.real = realTemp\r\n        \r\n        iterations ++\r\n        if(iterations == iterationDepth){\r\n            return true\r\n        }\r\n        \r\n    }\r\n    return false\r\n}\r\n\r\n/*\r\n                setTimeout in Schleifen:\r\n\r\nsetTimeout f\u00FChrt den angegebenen Callback asynchron aus. Dadurch wird der Inhalt von setTimeout nicht blockierend ausgef\u00FChrt, sondern in die Warteschlange (Event Loop) gestellt. Das kann zu unerwartetem Verhalten f\u00FChren, insbesondere wenn die Schleife schnell durchl\u00E4uft.\r\nDa die Schleife nicht wartet, bis der setTimeout-Callback ausgef\u00FChrt wurde, k\u00F6nnen Werte von Variablen wie directionVector oder actualPoint zwischenzeitlich weiter ver\u00E4ndert werden, was zu falschen Ergebnissen f\u00FChren kann.\r\n         */", "export interface Complex{\r\n  real: number\r\n  imag: number\r\n}\r\n\r\n// Discrete Fourier-Transformation\r\nexport function dft(data: Complex[]): Complex[] {\r\n  const N = data.length;\r\n  const result: Complex[] = [];\r\n\r\n  for (let k = 0; k < N; k++) {\r\n    let sum: Complex = { real: 0, imag: 0 };\r\n\r\n    for (let n = 0; n < N; n++) {\r\n      const angle = (2 * Math.PI * k * n) / N;\r\n      const cos = Math.cos(angle);\r\n      const sin = Math.sin(angle);\r\n\r\n      sum.real += data[n].real * cos + data[n].imag * sin;\r\n      sum.imag += data[n].imag * cos - data[n].real * sin;\r\n    }\r\n\r\n    // Amplituden normalisieren\r\n    sum.real /= N;\r\n    sum.imag /= N;\r\n\r\n    result.push(sum);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// inverse discrete fourier transformation\r\nexport function idft(coefficients: Complex[], N: number): Complex[] {\r\n  const result: Complex[] = [];\r\n\r\n  for (let n = 0; n < N; n++) {\r\n    let sum: Complex = { real: 0, imag: 0 };\r\n\r\n    for (let k = 0; k < coefficients.length; k++) {\r\n      const angle = (2 * Math.PI * k * n) / N;\r\n      const cos = Math.cos(angle);\r\n      const sin = Math.sin(angle);\r\n\r\n      sum.real += coefficients[k].real * cos - coefficients[k].imag * sin;\r\n      sum.imag += coefficients[k].real * sin + coefficients[k].imag * cos;\r\n    }\r\n\r\n    result.push(sum);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function extract(\r\n  points: {real: number, imag: number}[], \r\n  part: \"real\" | \"imag\"\r\n): {index: number, value: number}[] {\r\n      return points.map((complex,index)=>({\r\n          index,\r\n          value: complex[part]\r\n\r\n      }))\r\n  }\r\n\r\n  export function extractValuesAsFloat32Array(\r\n    points: { real: number; imag: number }[],\r\n    part: \"real\" | \"imag\"\r\n  ): Float32Array {\r\n    return new Float32Array(points.map((complex) => complex[part]));\r\n  }\r\n\r\nlet audioContext: AudioContext | null = null;\r\nexport let oscillator: OscillatorNode | null = null;\r\n\r\n/**\r\n * Create an oscillator from a custom waveform.\r\n * @param data - Array of objects with `real` and `imag` properties defining the waveform.\r\n */\r\nexport async function createOscillatorFromWaveform(frequency: number, data: { real: number; imag: number }[]) {\r\n    if (!audioContext) {\r\n        audioContext = new AudioContext();\r\n    }\r\n    oscillator = audioContext.createOscillator();\r\n\r\n    // Extract real and imag values into separate arrays\r\n    const realValues = new Float32Array(data.map(point => point.real));\r\n    const imagValues = new Float32Array(data.map(point => point.imag));\r\n\r\n    // Create a PeriodicWave\r\n    const wave = audioContext.createPeriodicWave(realValues, imagValues);\r\n\r\n    // Set the waveform and connect the oscillator\r\n    oscillator.setPeriodicWave(wave);\r\n    oscillator.connect(audioContext.destination);\r\n\r\n    // Set frequency\r\n    oscillator.frequency.value = frequency\r\n\r\n    // Start the oscillator\r\n    oscillator.start();\r\n}\r\n\r\n\r\n\r\n/**\r\n * Stop the sound and release resources.\r\n */\r\nexport function stopSound() {\r\n    if (oscillator) {\r\n        oscillator.stop();\r\n        oscillator.disconnect();\r\n        oscillator = null;\r\n    }\r\n\r\n    if (audioContext) {\r\n        audioContext.close();\r\n        audioContext = null;\r\n    }\r\n}\r\n\r\nfunction normalizeWaveform(data: { index: number; value: number }[]): Float32Array {\r\n    const values = data.map((d) => d.value);\r\n    const max = Math.max(...values);\r\n    const min = Math.min(...values);\r\n    return Float32Array.from(values.map((v) => 2 * (v - min) / (max - min) - 1)); // Normierung auf [-1, 1]\r\n  }\r\n  \r\n\r\n\r\n/*\r\n\r\nFalls dein Array keine periodische Wellenform darstellt oder du es direkt ohne Interpolation abspielen m\u00F6chtest, kannst du stattdessen einen AudioBuffer verwenden. Dies erzeugt einen einzelnen Klang und ist keine kontinuierliche Schwingung:\r\nconst data = [\r\n  { index: 0, value: 0 },\r\n  { index: 1, value: 0.5 },\r\n  { index: 2, value: 1 },\r\n  { index: 3, value: 0.5 },\r\n  { index: 4, value: 0 },\r\n  { index: 5, value: -0.5 },\r\n  { index: 6, value: -1 },\r\n  { index: 7, value: -0.5 },\r\n]; // Beispiel einer Wellenform\r\n\r\ncreateOscillatorFromWaveform(data).catch((err) => console.error(err));\r\n\r\nasync function playWaveform(data: { index: number; value: number }[], sampleRate = 44100) {\r\n  const audioContext = new AudioContext();\r\n\r\n  // Normalisiere die Wellenform\r\n  const normalizedWaveform = normalizeWaveform(data);\r\n\r\n  // Erstelle einen AudioBuffer\r\n  const buffer = audioContext.createBuffer(1, normalizedWaveform.length, sampleRate);\r\n  const channelData = buffer.getChannelData(0);\r\n  channelData.set(normalizedWaveform);\r\n\r\n  // AudioBufferSourceNode erstellen\r\n  const source = audioContext.createBufferSource();\r\n  source.buffer = buffer;\r\n  source.connect(audioContext.destination);\r\n\r\n  // Abspielen\r\n  source.start();\r\n}\r\n*/", "\r\nconsole.log(\"ver 2219\")\r\n\r\nimport { calcMandelbrotOutline, mirrorX} from \"./calcMandelbrotOutline.js\";\r\nimport { Complex, dft, idft, extractValuesAsFloat32Array, createOscillatorFromWaveform, stopSound} from \"./library.js\";\r\n\r\nconst wrapper = document.getElementById(\"wrapper\")\r\nlet audioContext: AudioContext | null = null\r\nlet oscillator: OscillatorNode | null = null\r\n\r\nexport const overviewSvgWidth =480\r\nexport const overviewSvgHeight = 420\r\nconst dftSvgWidth = 480\r\nconst dftSvgHeight = 420\r\n\r\nlet width = 2.5\r\nlet height = width\r\nexport let iterationDepth = 4;  // Iterationstiefe\r\nexport let xMin = -2, xMax = xMin + width\r\nexport let yMin = -1.2, yMax = yMin + height\r\nexport let animationRequest = true\r\n\r\nlet samplePoints: Complex[] = []\r\nlet sampleCurvePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\nlet dftPoints: Complex[] = []\r\nlet dftPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\") \r\nlet idftPoints: Complex[] = []\r\nlet idftPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\nlet inversionAccuracy = 169\r\n\r\nconst headline: HTMLHeadElement = document.createElement(\"h1\")\r\nupdateHeadline()\r\n\r\n// there is the constructed mandelbrot line in the left window\r\nexport const sampleCurveSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nsampleCurveSvg.setAttribute(\"id\", \"sampleCurveSvg\")\r\nsampleCurveSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\nsampleCurveSvg.setAttribute(\"width\", `${overviewSvgWidth}px`)\r\nsampleCurveSvg.setAttribute(\"height\", `${overviewSvgHeight}px`)\r\n\r\n// and there is the place where the transformed sampleCurve is plotted\r\nconst dftSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\ndftSvg.setAttribute(\"id\", \"dftSvg\")\r\ndftSvg.setAttribute(\"width\", `${dftSvgWidth}`)\r\ndftSvg.setAttribute(\"height\", `${dftSvgHeight}`)\r\ndftSvg.setAttribute(\"viewBox\", \"-1 -1 2 2\")\r\n\r\n// there is the reconstructed Fourier-analysed curve in the right window (Inverse Discrete Fourier-Transformation)\r\nexport const idftSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nidftSvg.setAttribute(\"id\", \"IDFTSvg\")\r\nidftSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} 4`)\r\nidftSvg.setAttribute(\"width\", `${overviewSvgWidth}px`)\r\nidftSvg.setAttribute(\"height\", `${overviewSvgHeight}px`)\r\n\r\nconst viewControlsContainer = document.createElement(\"div\")\r\nviewControlsContainer.id = \"viewControlsContainer\"\r\nviewControlsContainer.style.border = \"1px solid black\"\r\nviewControlsContainer.style.padding = \"10px\"\r\n\r\nconst viewElementsContainer = document.createElement(\"div\")\r\nviewElementsContainer.id = \"viewElementsContainer\"\r\nviewElementsContainer.style.border = \"1px solid black\"\r\nviewElementsContainer.style.padding = \"10px\"\r\n\r\nconst soundControlsContainer = document.createElement(\"div\")\r\nsoundControlsContainer.id = \"soundControlsContainer\"\r\nsoundControlsContainer.style.border = \"1px solid black\"\r\nsoundControlsContainer.style.padding = \"10px\"\r\n\r\n\r\nsamplePoints = calcMandelbrotOutline()\r\n\r\nsampleCurvePath = drawLines(mirrorX(samplePoints))\r\nsampleCurveSvg.appendChild(sampleCurvePath)\r\n\r\ndftPoints = dft(samplePoints)\r\ndftPath = drawLines(dftPoints)\r\ndftSvg.appendChild(dftPath)\r\n\r\nidftPoints = idft(dftPoints, inversionAccuracy)\r\nidftPath = drawLines(idftPoints)\r\nidftSvg.appendChild(idftPath)\r\n\r\nconst soundButton = document.createElement(\"button\")\r\nsoundButton.innerHTML = \"oscillate boundary points\"\r\nsoundButton.style.width = \"200px\"\r\nlet isPlaying = false\r\n\r\nsoundButton.addEventListener(\"click\", ()=>{\r\n    if(!audioContext){\r\n        audioContext = new AudioContext()\r\n    }\r\n    if(!isPlaying){\r\n        soundButton.textContent = \"stop sound\"\r\n        const sample = samplePoints\r\n        const wave = audioContext.createPeriodicWave(extractValuesAsFloat32Array(sample, \"real\"), \r\n                                                    extractValuesAsFloat32Array(sample, \"imag\")\r\n                                                )\r\n        \r\n    }\r\n\r\n    if(isPlaying){\r\n        stopSound()\r\n        soundButton.textContent = \"oscillate boundary points\"\r\n    }\r\n    isPlaying = !isPlaying\r\n\r\n})\r\n\r\n// control-element for the iteration-depth\r\nconst iterationDepthSliderLabel = document.createElement(\"label\")\r\niterationDepthSliderLabel.setAttribute(\"for\", \"iterationsSlider\")\r\niterationDepthSliderLabel.innerHTML = \"iterations: \"\r\nconst iterationDepthSlider = document.createElement(\"input\")\r\niterationDepthSlider.id = \"iterationsSlider\"\r\niterationDepthSlider.type = \"range\"\r\niterationDepthSlider.min = \"2\"\r\niterationDepthSlider.max = \"14\"\r\niterationDepthSlider.step = \"1\"\r\niterationDepthSlider.value = `${iterationDepth}`\r\n\r\n// control-Element for the amount of samples used for the inverse Fourier-Transformation\r\nconst inversionAccuracySliderLabel = document.createElement(\"label\")\r\ninversionAccuracySliderLabel.setAttribute(\"for\", \"inversionAmountSlider\")\r\ninversionAccuracySliderLabel.innerHTML = \"reversion accuracy: \"\r\nconst inversionAccuracySlider = document.createElement(\"input\")\r\ninversionAccuracySlider.id = \"sampleAmountSlider\"\r\ninversionAccuracySlider.type = \"range\"\r\ninversionAccuracySlider.min = \"1\"\r\ninversionAccuracySlider.max = `${samplePoints.length}`\r\ninversionAccuracySlider.step = \"1\"\r\ninversionAccuracySlider.value = `${inversionAccuracy}`\r\n\r\nviewControlsContainer.appendChild(iterationDepthSliderLabel)\r\nviewControlsContainer.appendChild(iterationDepthSlider)\r\nviewControlsContainer.appendChild(inversionAccuracySliderLabel)\r\nviewControlsContainer.appendChild(inversionAccuracySlider)\r\n\r\nviewElementsContainer.appendChild(sampleCurveSvg)\r\nviewElementsContainer.appendChild(dftSvg)\r\nviewElementsContainer.appendChild(idftSvg)\r\n\r\nwrapper?.appendChild(headline)\r\nwrapper?.appendChild(soundControlsContainer)\r\nwrapper?.appendChild(viewControlsContainer)\r\nwrapper?.appendChild(viewElementsContainer)\r\n\r\niterationDepthSlider.addEventListener(\"input\", function(event){\r\n    iterationDepth = parseInt(iterationDepthSlider.value)\r\n    updateHeadline()\r\n\r\n    samplePoints = calcMandelbrotOutline()\r\n    sampleCurvePath = drawLines(mirrorX(samplePoints))\r\n    sampleCurveSvg.innerHTML = \"\"\r\n    sampleCurveSvg.appendChild(sampleCurvePath)\r\n\r\n    inversionAccuracySlider.max = samplePoints.length.toString()\r\n\r\n    dftPoints = dft(samplePoints)\r\n    dftSvg.innerHTML = \"\"\r\n    dftSvg.appendChild(drawLines(dftPoints))\r\n\r\n    idftSvg.innerHTML = \"\"\r\n    idftSvg.appendChild(drawDots(idft(dftPoints, inversionAccuracy)))\r\n})\r\n\r\ninversionAccuracySlider.addEventListener(\"input\", function(){\r\n    inversionAccuracy = parseFloat(inversionAccuracySlider.value)\r\n    updateHeadline()\r\n\r\n    idftPath = drawDots(idft(dftPoints, inversionAccuracy))\r\n    idftSvg.innerHTML = \"\"\r\n    idftSvg.appendChild(idftPath)\r\n    \r\n})\r\n\r\nsampleCurveSvg.addEventListener(\"mouseleave\", () => {\r\n    mousedown = false\r\n})\r\n\r\nlet xOffset: number\r\nlet yOffset: number\r\nlet mousedown = false\r\nsampleCurveSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(sampleCurveSvg, event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\n\r\nsampleCurveSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(sampleCurveSvg, event);\r\n    xMin += xOffset - coords.x\r\n    yMin += yOffset - coords.y\r\n    sampleCurveSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\nsampleCurveSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    drawLines(samplePoints)\r\n})\r\n\r\nsampleCurveSvg.addEventListener(\"wheel\", (event) =>{\r\n    \r\n    let deltaY = event.deltaY\r\n    const clientWidth = sampleCurveSvg.getBoundingClientRect().width\r\n    const mouseX = event.x - sampleCurveSvg.getBoundingClientRect().x\r\n    const clientHeight = sampleCurveSvg.getBoundingClientRect().height\r\n    const mouseY = event.y - sampleCurveSvg.getBoundingClientRect().y\r\n\r\n    if(Math.abs(deltaY) < 100){\r\n        if(deltaY <= 0)\r\n            deltaY -= 100\r\n        else\r\n            deltaY += 100\r\n    }\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width += width * 10 / deltaY \r\n    height = width\r\n    \r\n    xMin -= (width - oldWidth) * mouseX / clientWidth \r\n    xMax = xMin + width\r\n    yMin -=(height - oldHeight) * mouseY / clientHeight \r\n    yMax = yMin + height\r\n\r\n    sampleCurveSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\nidftSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(idftSvg, event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\nidftSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(idftSvg, event);\r\n    xMin += xOffset - coords.x\r\n    yMin += yOffset - coords.y\r\n    idftSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n})\r\nidftSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    \r\n})\r\nidftSvg.addEventListener(\"wheel\", (event) =>{\r\n    const clientWidth = idftSvg.getBoundingClientRect().width\r\n    const mouseX = event.x - idftSvg.getBoundingClientRect().x\r\n    const clientHeight = idftSvg.getBoundingClientRect().height\r\n    const mouseY = event.y - idftSvg.getBoundingClientRect().y\r\n\r\n    // differentiate between mousewheel and touchpad\r\n    let deltaY = event.deltaY\r\n    if(Math.abs(deltaY) < 100){\r\n        if(deltaY <= 0)\r\n            deltaY -= 100\r\n        else\r\n            deltaY += 100\r\n    }\r\n\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width += width * 10 / deltaY \r\n    height = width\r\n    \r\n    xMin -= (width - oldWidth ) * mouseX / clientWidth\r\n    xMax = xMin + width\r\n    yMin -=(height - oldHeight) * mouseY / clientHeight\r\n    yMax = yMin + height\r\n\r\n    idftSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\ndftSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(dftSvg, event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\ndftSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(dftSvg, event);\r\n    xMin += xOffset - coords.x\r\n    yMin += yOffset - coords.y\r\n    dftSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n})\r\ndftSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    \r\n})\r\ndftSvg.addEventListener(\"wheel\", (event) =>{\r\n    const clientWidth = dftSvg.getBoundingClientRect().width\r\n    const mouseX = event.x - dftSvg.getBoundingClientRect().x\r\n    const clientHeight = dftSvg.getBoundingClientRect().height\r\n    const mouseY = event.y - dftSvg.getBoundingClientRect().y\r\n\r\n    // differentiate between mousewheel and touchpad\r\n    let deltaY = event.deltaY\r\n    if(Math.abs(deltaY) < 100){\r\n        if(deltaY <= 0)\r\n            deltaY -= 100\r\n        else\r\n            deltaY += 100\r\n    }\r\n\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width += width * 10 / deltaY \r\n    height = width\r\n    \r\n    xMin -= (width - oldWidth ) * mouseX / clientWidth\r\n    xMax = xMin + width\r\n    yMin -=(height - oldHeight) * mouseY / clientHeight\r\n    yMax = yMin + height\r\n\r\n    dftSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\n// Helper to get SVG coordinates\r\nfunction getSvgCoords(svgElement: SVGSVGElement, event: MouseEvent) {\r\n    const point = svgElement.createSVGPoint();\r\n    point.x = event.clientX;\r\n    point.y = event.clientY;\r\n    const svgCoords = point.matrixTransform(svgElement.getScreenCTM()!.inverse());\r\n    return svgCoords;\r\n}\r\n\r\n\r\nfunction drawLines(samplePoints: Complex[]): SVGPathElement {\r\n    const sampleCurvePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\n\r\n    if(samplePoints.length < 2){\r\n        console.warn(\"Not enough points to draw lines\")\r\n        return sampleCurvePath\r\n    }\r\n    \r\n    let pathData = `M${samplePoints[0].real} ${samplePoints[0].imag}`\r\n    for(let i = 1; i<samplePoints.length; i++){\r\n        pathData += `L ${samplePoints[i].real} ${samplePoints[i].imag}`\r\n    }\r\n    \r\n    sampleCurvePath.setAttribute(\"id\", \"outlinePath\")\r\n    sampleCurvePath.setAttribute(\"fill\", \"none\")\r\n    sampleCurvePath.setAttribute(\"stroke\", \"black\")\r\n    sampleCurvePath.setAttribute(\"stroke-width\", \".5 px\")\r\n    sampleCurvePath.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n    sampleCurvePath.setAttribute(\"d\", `${pathData}`)\r\n\r\n    return sampleCurvePath\r\n}\r\nfunction drawDots(samplePoints: Complex[]): SVGPathElement {\r\n    const sampleCurvePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\n\r\n    if(samplePoints.length < 2){\r\n        console.warn(\"Not enough points to draw lines\")\r\n        return sampleCurvePath\r\n    }\r\n    \r\n    let pathData = \"\"\r\n    for(let i = 1; i<samplePoints.length; i++){\r\n        pathData += ` M ${samplePoints[i].real} ${samplePoints[i].imag} v .01`\r\n    }\r\n    sampleCurvePath.setAttribute(\"id\", \"outlinePath\")\r\n    sampleCurvePath.setAttribute(\"fill\", \"none\")\r\n    sampleCurvePath.setAttribute(\"stroke\", \"black\")\r\n    sampleCurvePath.setAttribute(\"stroke-width\", \".5 px\")\r\n    sampleCurvePath.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n    sampleCurvePath.setAttribute(\"d\", `${pathData}`)\r\n\r\n    return sampleCurvePath\r\n}\r\n\r\nfunction drawExtrapolatedCurve(points: {index: number, value: number}[]): SVGPathElement{\r\n    \r\n    // Skalierung f\u00FCr die X- und Y-Koordinaten basierend auf `i` und `real`-Werten\r\n    const width = dftSvgWidth\r\n    const height = dftSvgHeight\r\n    const xScale = width / (points.length - 1); // Breite durch Anzahl der Punkte\r\n    const yMin = Math.min(...points.map(p => p.value));\r\n    const yMax = Math.max(...points.map(p => p.value));\r\n    const yScale = height / (yMax - yMin);\r\n\r\n    // Erzeuge die \"d\"-Attribute f\u00FCr das <path>-Element\r\n    let pathData = `M 0 ${height - (points[0].value - yMin) * yScale}`;\r\n    for (let j = 1; j < points.length; j++) {\r\n        const x = j * xScale;\r\n        const y = height - (points[j].value - yMin) * yScale;\r\n        pathData += ` L ${x} ${y}`;\r\n    }\r\n    \r\n\r\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"id\", \"extrapolatedCurve\")\r\n    path.setAttribute(\"d\", pathData);\r\n    path.setAttribute(\"fill\", \"none\");\r\n    path.setAttribute(\"stroke\", \"blue\");\r\n    path.setAttribute(\"stroke-width\", \"2\");\r\n    return (path);\r\n}\r\n\r\nfunction updateHeadline(){\r\n    headline.innerHTML = headline.innerHTML = `Mandelbrot-outline at depth: ${iterationDepth} is transformed by discrete-Fourier-transformation and transformed back the first ${inversionAccuracy} elements of the transformed values`\r\n}"],
  "mappings": "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",
  "names": ["samplePoints", "audioContext", "audioContext", "samplePoints", "sampleCurvePath"]
}
