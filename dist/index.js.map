{
  "version": 3,
  "sources": ["../src/calcMandelbrotOutline.ts", "../src/calcnPlot.ts", "../src/index.ts"],
  "sourcesContent": ["import { iterationDepth } from \"src\"\r\n\r\nexport let boundaryPoints: {real: number, imag:number}[] = []\r\nexport function calcMandelbrotOutline(){\r\n\r\n    boundaryPoints=[]\r\n    \r\n    // start from the well known left tip of the mandelbrot-set\r\n    const startPoint = {real: -2, imag:0}\r\n    \r\n    //step slightly out of the mandelbrotset at samplingRate/2 step\r\n    let directionVector = {real: -1, imag: 0}\r\n    const samplingRate = 1/Math.pow(iterationDepth,3)\r\n    const sampleRotation = Math.PI/8\r\n    let actualPoint = add(startPoint, scale(directionVector, samplingRate/2))\r\n\r\n    console.log(\"samplingRate: \"+samplingRate+\" at iterationDepth: \"+iterationDepth)\r\n    \r\n\r\n    boundaryPoints.push(actualPoint)\r\n    \r\n    // then move upwards from here on\r\n    directionVector = {real: 0, imag: 1}\r\n\r\n    //move around the whole mandelbroz\r\n    while (actualPoint.real < 0){\r\n    //for (let i = 0; i  < 1500; i++) {\r\n       \r\n        // test if actualPoint + directionVector is inside the Mandelbrot\r\n        // cover the case, where we pierce into the set\r\n        if(mandelbrot(add(actualPoint, scale(directionVector, samplingRate)))){\r\n                while (mandelbrot(add(actualPoint, scale(directionVector, samplingRate)))){\r\n                    // adjust by rotating the directionvector away from the set\r\n                    \r\n                    directionVector = rotate(directionVector, sampleRotation)\r\n                }\r\n            actualPoint = add(actualPoint, scale(directionVector, samplingRate))\r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    \r\n        // cover the case, where we do not pierce into the set\r\n        if(!mandelbrot(add(actualPoint, scale(directionVector, samplingRate)))){\r\n            while(!mandelbrot(add(actualPoint, scale(directionVector, samplingRate))))    {\r\n                //rotate the other way around\r\n                directionVector = rotate(directionVector, -sampleRotation)\r\n            }\r\n            // then rotate back to get out of the set again\r\n            directionVector = rotate(directionVector, sampleRotation)\r\n            actualPoint = add(actualPoint, scale(directionVector, samplingRate))\r\n            boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    }\r\n    console.log(\"boundaryPoints.length: \"+boundaryPoints.length)\r\n   \r\n}\r\n\r\nfunction rotate(vector: {real: number, imag: number}, rotationAngle: number): {real: number, imag: number}{\r\n    const originLength = Math.sqrt(Math.pow(vector.real,2)+ Math.pow(vector.imag,2))\r\n    const originAngle = Math.atan2(vector.imag, vector.real)\r\n    const destinationAngle = originAngle + rotationAngle\r\n    const rotatedVector = scale({real: Math.cos(destinationAngle), imag: Math.sin(destinationAngle)}, originLength)\r\n    return rotatedVector\r\n}\r\n\r\nfunction scale(vector: {real: number, imag: number}, amount: number): {real: number, imag: number}{\r\n    return {real: vector.real * amount, imag: vector.imag * amount}\r\n}\r\n\r\nfunction add(v1: {real: number, imag: number}, v2: {real: number, imag: number}): {real: number, imag: number}{\r\n    return {real: v1.real + v2.real, imag: v1.imag + v2.imag}\r\n}\r\n\r\nfunction mandelbrot(c: {real: number, imag: number}): boolean{\r\n    let z = { real: c.real, imag: c.imag };\r\n    let iterations = 0;\r\n    while((iterations < iterationDepth) && (z.real * z.real + z.imag * z.imag) <= 4){\r\n        let realTemp  = z.real * z.real - z.imag * z.imag + c.real\r\n        z.imag = 2 * z.real * z.imag + c.imag\r\n        z.real = realTemp\r\n        \r\n        iterations ++\r\n        if(iterations == iterationDepth){\r\n            return true\r\n        }\r\n        \r\n    }\r\n    return false\r\n}", "\r\nimport { canvas, xMax, xMin, yMax, yMin, iterationDepth} from \"src\";\r\n\r\nexport class Mandelbrot{\r\n    ctx = canvas.getContext(\"2d\");\r\n    width = canvas.width;\r\n    height = canvas.height;\r\n   \r\n    boundaryPoints: {x:number, y: number}[]  = []\r\n\r\n    // Skalierungsfunktionen von Canvas-Koordinaten auf komplexe Zahlenebene\r\n    scaleX(x: number) { return xMin + (x / this.width) * (xMax - xMin); }\r\n    scaleY(y: number) { return yMin + (y / this.height) * (yMax - yMin); }\r\n\r\n    // Mandelbrot-Iteration\r\n    mandelbrot(viewPortCoordinate: {x: number, y: number}) {\r\n        const c = {real: this.scaleX(viewPortCoordinate.x), imag: this.scaleY(viewPortCoordinate.y)}\r\n        let z = { real: 0, imag: 0 };\r\n        let iterations = 0;\r\n        \r\n        while (iterations < iterationDepth && ( z.real * z.real + z.imag * z.imag <= 4)) {\r\n            let realTemp = z.real * z.real - z.imag * z.imag + c.real;\r\n            z.imag = 2 * z.real * z.imag + c.imag;\r\n            z.real = realTemp;\r\n            iterations++;\r\n            if (iterations == iterationDepth && z.real * z.real + z.imag * z.imag > 3.5 && z.real * z.real + z.imag * z.imag <= 4.5){\r\n                return viewPortCoordinate\r\n            }\r\n        }\r\n\r\n        \r\n    }\r\n\r\n    // Grenzlinie berechnen und plotten\r\n    drawCloud() {\r\n        this.boundaryPoints = [];\r\n\r\n        for (let x = 0; x < this.width; x++) {\r\n            for (let y = 0; y < this.height; y++) {\r\n                const c = { x: x, y: y };\r\n                const borderPoint = this.mandelbrot(c);\r\n\r\n                // Nur Punkte, die genau nach der Iterationstiefe die Grenze \u00FCberschreiten, werden aufgenommen\r\n                if(borderPoint)\r\n                    this.boundaryPoints.push(borderPoint)\r\n            }\r\n        }\r\n\r\n        // Punkte auf der Canvas zeichnen\r\n        if(this.ctx){\r\n            this.ctx.fillStyle = \"white\"\r\n            this.ctx.fillRect(0,0,canvas.width, canvas.height)\r\n            \r\n            this.ctx.fillStyle = \"blue\";\r\n                this.boundaryPoints.forEach(point => {\r\n                    this.ctx!.fillRect(point.x, point.y, 1, 1);\r\n                });\r\n        }\r\n    }\r\n    \r\n}    ", "\r\nimport { boundaryPoints, calcMandelbrotOutline } from \"./calcMandelbrotOutline.js\";\r\nimport { Mandelbrot } from \"./calcnPlot.js\";\r\n\r\nconst wrapper = document.getElementById(\"wrapper\")\r\nconst canvasWidth = 800\r\nconst canvasHeight = 800\r\nlet width = 4\r\nlet height = width\r\nexport let iterationDepth = 5;  // Iterationstiefe\r\nexport let xMin = -2.5, xMax = xMin + width\r\nexport let yMin = -2, yMax = yMin + height;\r\n\r\nconst headline: HTMLHeadElement = document.createElement(\"h1\")\r\nheadline.innerHTML = `Mandelbrot-Grenzlinie bei Iterationstiefe i = ${iterationDepth}`\r\n\r\nexport const canvas = document.createElement(\"canvas\")\r\ncanvas.setAttribute(\"id\", \"mandelbrotCanvas\")\r\ncanvas.setAttribute(\"width\", `${canvasWidth}px`)\r\ncanvas.setAttribute(\"height\", `${canvasHeight}px`)\r\n\r\nconst iterationsSliderLabel = document.createElement(\"label\")\r\niterationsSliderLabel.setAttribute(\"for\", \"iterationsSlider\")\r\niterationsSliderLabel.innerHTML = \"iterations: \"\r\nconst iterationsSlider = document.createElement(\"input\")\r\niterationsSlider.id = \"iterationsSlider\"\r\niterationsSlider.type = \"range\"\r\niterationsSlider.min = \"2\"\r\niterationsSlider.max = \"13\"\r\niterationsSlider.step = \"1\"\r\niterationsSlider.value = `${iterationDepth}`\r\n\r\nconst xMinSliderLabel = document.createElement(\"label\")\r\nxMinSliderLabel.setAttribute(\"for\", \"xMinSlider\")\r\nxMinSliderLabel.innerHTML = \"x-move:\"\r\nconst xMinSlider = document.createElement(\"input\")\r\nxMinSlider.id = \"xMinSlider\"\r\nxMinSlider.type = \"range\"\r\nxMinSlider.min = \"-6\"\r\nxMinSlider.max = \"2.0\"\r\nxMinSlider.step = \".1\"\r\nxMinSlider.value = `${xMin}`\r\n\r\nconst yMinSliderLabel = document.createElement(\"label\")\r\nyMinSliderLabel.setAttribute(\"for\", \"yMinSlider\")\r\nyMinSliderLabel.innerHTML = \"y-move:\"\r\nconst yMinSlider = document.createElement(\"input\")\r\nyMinSlider.id = \"yMinslider\"\r\nyMinSlider.type = \"range\"\r\nyMinSlider.min =\"-6\"\r\nyMinSlider.max = \"2\"\r\nyMinSlider.step = \".1\"\r\nyMinSlider.value = `${yMin}`\r\n\r\nconst zoomSliderLabel = document.createElement(\"label\")\r\nzoomSliderLabel.setAttribute(\"for\", \"zoomSlider\")\r\nzoomSliderLabel.innerHTML = \"zoom: \"\r\nconst zoomSlider = document.createElement(\"input\")\r\nzoomSlider.id = \"widthSlider\"\r\nzoomSlider.type = \"range\"\r\nzoomSlider.min = \".1\"\r\nzoomSlider.max = \"4\"\r\nzoomSlider.step = \".1\"\r\nzoomSlider.value = `${width}`\r\n\r\nwrapper?.appendChild(headline)\r\nwrapper?.appendChild(iterationsSliderLabel)\r\nwrapper?.appendChild(iterationsSlider)\r\nwrapper?.appendChild(xMinSliderLabel)\r\nwrapper?.appendChild(xMinSlider)\r\nwrapper?.appendChild(yMinSliderLabel)\r\nwrapper?.appendChild(yMinSlider)\r\nwrapper?.appendChild(zoomSliderLabel)\r\nwrapper?.appendChild(zoomSlider)\r\nwrapper?.appendChild(canvas)\r\n\r\n// draw a MandelbrotCloud for reference\r\nconst mandelbrot = new Mandelbrot()\r\nmandelbrot.drawCloud()\r\nconst ctx = canvas.getContext(\"2d\")\r\n\r\n// calc and plot MandelbrotOutline\r\nconsole.log(\"calling calcMandelbrotOutline\")\r\ncalcMandelbrotOutline()\r\ndrawLines()\r\n\r\niterationsSlider.addEventListener(\"input\", function(event){\r\n    iterationDepth = parseInt(iterationsSlider.value)\r\n    headline.innerHTML = `Mandelbrot-Grenzlinie bei Iterationstiefe i = ${iterationDepth}`\r\n    mandelbrot.drawCloud()\r\n    calcMandelbrotOutline()\r\n    if (iterationDepth<11)\r\n    drawLines()\r\n})\r\n\r\nxMinSlider.addEventListener(\"input\", function(){\r\n    xMin = parseFloat(xMinSlider.value)\r\n    xMax = xMin + width\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\nyMinSlider.addEventListener(\"input\", function(){\r\n    yMin = parseFloat(yMinSlider.value)\r\n    yMax = yMin + height\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\nzoomSlider.addEventListener(\"input\", function(){\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width = parseFloat(zoomSlider.value)\r\n    height = width\r\n    xMin -= (width - oldWidth )/2\r\n    xMax = xMin + width\r\n    \r\n    yMin -=(height - oldHeight)/2\r\n    yMax = yMin + height\r\n\r\n    xMinSlider.step = (parseFloat(zoomSlider.value)/40).toString()\r\n    yMinSlider.step = (parseFloat(zoomSlider.value)/40).toString()\r\n    mandelbrot.drawCloud()\r\n    drawLines()\r\n})\r\n\r\nfunction mapToCanvas(point: {real: number, imag: number}): {x: number, y: number}{\r\n    const x = ((point.real - xMin) / (xMax - xMin)) * canvasWidth; // Bereich real -2 bis 2 auf 0 bis canvasWidth skalieren\r\n    const y =   ((point.imag - yMin) / (yMax - yMin)) * canvasHeight; // Bereich imag -2 bis 2 auf 0 bis canvasHeight skalieren (invertiert f\u00FCr Canvas-Koordinaten)\r\n    return { x, y };\r\n}\r\n\r\nfunction drawLines(){\r\n    if(boundaryPoints.length < 2){\r\n        console.warn(\"Not enough points to draw lines\")\r\n        return;\r\n    }\r\n    const canvasPoints = boundaryPoints.map(point => mapToCanvas(point))\r\n    ctx?.beginPath();\r\n    ctx?.moveTo(canvasPoints[0].x, canvasPoints[0].y)\r\n\r\n    // Linien zu den restlichen Punkten zeichnen\r\n    for (let i = 1; i < canvasPoints.length; i++) {\r\n    ctx?.lineTo(canvasPoints[i].x, canvasPoints[i].y);\r\n\r\n    // Linienfarbe und Breite setzen, und die Linien zeichnen\r\n    ctx!.strokeStyle = \"black\";\r\n    ctx!.lineWidth = 1;\r\n    ctx?.stroke();\r\n  }\r\n}"],
  "mappings": "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",
  "names": ["mandelbrot"]
}
