{
  "version": 3,
  "sources": ["../src/library.ts", "../src/calcMandelbrotOutline.ts", "../src/index.ts"],
  "sourcesContent": ["import { MandelbrotOutline } from \"./calcMandelbrotOutline\";\r\nimport { Mandelbrot } from \"./calcnPlot\";\r\n\r\nexport interface Complex{\r\n  real: number\r\n  imag: number\r\n}\r\n\r\nexport interface IterationData {\r\n  rawSample: Complex[];\r\n  rawLines: SVGPathElement;\r\n  dftSample: Complex[];\r\n  dftLines?: SVGPathElement;\r\n  dftDots?: SVGPathElement;\r\n}\r\n\r\nexport const storage: Map<number, IterationData> = new Map();\r\n\r\nasync function calculateRawData(iterationDepth: number): Promise<Complex[]> {\r\n  const outline = new MandelbrotOutline(iterationDepth);\r\n  const rawData: Complex[] = await outline.calcMandelbrotOutline();\r\n  return rawData;\r\n}\r\n\r\n\r\nasync function calculateAndStore(iterationDepth: number): Promise<void> {\r\n  if (iterationDepth < 3) {\r\n      console.error(\"Minimum iteration depth is 3\");\r\n      return;\r\n  }\r\n  if (iterationDepth > 14) {\r\n      console.error(\"Maximum algorithm capability is 14\");\r\n      return;\r\n  }\r\n\r\n  if (storage.has(iterationDepth)) {\r\n      console.log(`Data for iteration depth ${iterationDepth} already exists.`);\r\n      return;\r\n  }\r\n\r\n  console.log(`Calculating data for iteration depth ${iterationDepth}...`);\r\n\r\n  // First calculate:\r\n  const rawSample: Complex[] = await calculateRawData(iterationDepth)\r\n  const dftSample: Complex[] = await dft(rawSample);\r\n  \r\n\r\n  // Daten in der Map speichern\r\n  storage.set(iterationDepth, { rawSample: rawSample, rawLines: drawLines(rawSample), dftSample: dftSample});\r\n\r\n  console.log(`Data for iteration depth ${iterationDepth} stored.`);\r\n}\r\n\r\n\r\nexport function mirrorX(samplePoints: Complex[]): Complex[]{\r\n  const arrayLength = samplePoints.length\r\n  const mirroredPoints = [...samplePoints]\r\n      for ( let index = arrayLength - 2; index >= 0; index--){\r\n          const reversedPoint = {real: samplePoints[index].real, imag: -samplePoints[index].imag}\r\n          mirroredPoints.push(reversedPoint)\r\n      }\r\n      return mirroredPoints\r\n}\r\n\r\nexport function rotate(vector: {real: number, imag: number}, rotationAngle: number): {real: number, imag: number}{\r\n  const originLength = Math.sqrt(Math.pow(vector.real,2)+ Math.pow(vector.imag,2))\r\n  const originAngle = Math.atan2(vector.imag, vector.real)\r\n  const destinationAngle = originAngle + rotationAngle\r\n  const rotatedVector = scale({real: Math.cos(destinationAngle), imag: Math.sin(destinationAngle)}, originLength)\r\n  return rotatedVector\r\n}\r\n\r\nexport function scale(vector: {real: number, imag: number}, amount: number): {real: number, imag: number}{\r\n  return {real: vector.real * amount, imag: vector.imag * amount}\r\n}\r\n\r\nexport function add(v1: {real: number, imag: number}, v2: {real: number, imag: number}): {real: number, imag: number}{\r\n  return {real: v1.real + v2.real, imag: v1.imag + v2.imag}\r\n}\r\n\r\n\r\n// Discrete Fourier-Transformation\r\nexport function dft(data: Complex[]): Complex[] {\r\n  const N = data.length;\r\n  const result: Complex[] = [];\r\n\r\n  for (let k = 0; k < N; k++) {\r\n    let sum: Complex = { real: 0, imag: 0 };\r\n\r\n    for (let n = 0; n < N; n++) {\r\n      const angle = (2 * Math.PI * k * n) / N;\r\n      const cos = Math.cos(angle);\r\n      const sin = Math.sin(angle);\r\n\r\n      sum.real += data[n].real * cos + data[n].imag * sin;\r\n      sum.imag += data[n].imag * cos - data[n].real * sin;\r\n    }\r\n\r\n    // Amplituden normalisieren\r\n    sum.real /= N;\r\n    sum.imag /= N;\r\n\r\n    result.push(sum);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// inverse discrete fourier transformation\r\nexport function idft(coefficients: Complex[], N: number): Complex[] {\r\n  const result: Complex[] = [];\r\n\r\n  for (let n = 0; n < N; n++) {\r\n    let sum: Complex = { real: 0, imag: 0 };\r\n\r\n    for (let k = 0; k < coefficients.length; k++) {\r\n      const angle = (2 * Math.PI * k * n) / N;\r\n      const cos = Math.cos(angle);\r\n      const sin = Math.sin(angle);\r\n\r\n      sum.real += coefficients[k].real * cos - coefficients[k].imag * sin;\r\n      sum.imag += coefficients[k].real * sin + coefficients[k].imag * cos;\r\n    }\r\n\r\n    result.push(sum);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function drawLines(samplePoints: Complex[]): SVGPathElement {\r\n  const sampleCurvePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\n\r\n  if(samplePoints.length < 2){\r\n      console.warn(\"Not enough points to draw lines\")\r\n      return sampleCurvePath\r\n  }\r\n  \r\n  let pathData = `M${samplePoints[0].real} ${samplePoints[0].imag}`\r\n  for(let i = 1; i<samplePoints.length; i++){\r\n      pathData += `L ${samplePoints[i].real} ${samplePoints[i].imag}`\r\n  }\r\n  \r\n  sampleCurvePath.setAttribute(\"id\", \"outlinePath\")\r\n  sampleCurvePath.setAttribute(\"fill\", \"none\")\r\n  sampleCurvePath.setAttribute(\"stroke\", \"black\")\r\n  sampleCurvePath.setAttribute(\"stroke-width\", \".5 px\")\r\n  sampleCurvePath.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n  sampleCurvePath.setAttribute(\"d\", `${pathData}`)\r\n\r\n  return sampleCurvePath\r\n}\r\n\r\nexport function pixelHeight(svgElem: SVGSVGElement): number{\r\n  \r\n  return(svgElem.viewBox.baseVal.height / svgElem.getBoundingClientRect().height)\r\n}\r\n\r\nexport function drawDots(samplePoints: Complex[], pixelHeight: number): SVGPathElement {\r\n  const sampleCurvePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\n  const strokeWidth = .5\r\n\r\n  console.log(pixelHeight)\r\n\r\n  let pathData = \"\"\r\n  for(let i = 1; i<samplePoints.length; i++){\r\n      pathData += `M ${samplePoints[i].real} ${samplePoints[i].imag} v ${pixelHeight}`\r\n  }\r\n  sampleCurvePath.setAttribute(\"id\", \"outlinePath\")\r\n  sampleCurvePath.setAttribute(\"fill\", \"none\")\r\n  sampleCurvePath.setAttribute(\"stroke\", \"black\")\r\n  sampleCurvePath.setAttribute(\"stroke-width\", `${strokeWidth}`)\r\n  sampleCurvePath.setAttribute(\"vector-effect\", \"non-scaling-stroke\")\r\n  sampleCurvePath.setAttribute(\"d\", `${pathData}`)\r\n\r\n  return sampleCurvePath\r\n}\r\n\r\nexport function extract(\r\n  points: {real: number, imag: number}[], \r\n  part: \"real\" | \"imag\"\r\n): {index: number, value: number}[] {\r\n      return points.map((complex,index)=>({\r\n          index,\r\n          value: complex[part]\r\n\r\n      }))\r\n  }\r\n\r\n  export function extractValuesAsFloat32Array(\r\n    points: { real: number; imag: number }[],\r\n    part: \"real\" | \"imag\"\r\n  ): Float32Array {\r\n    return new Float32Array(points.map((complex) => complex[part]));\r\n  }\r\n\r\nlet audioContext: AudioContext | null = null;\r\nexport let oscillator: OscillatorNode | null = null;\r\n\r\n/**\r\n * Create an oscillator from a custom waveform.\r\n * @param data - Array of objects with `real` and `imag` properties defining the waveform.\r\n */\r\nexport async function createOscillatorFromWaveform(frequency: number, data: { real: number; imag: number }[]) {\r\n    if (!audioContext) {\r\n        audioContext = new AudioContext();\r\n    }\r\n    oscillator = audioContext.createOscillator();\r\n\r\n    // Extract real and imag values into separate arrays\r\n    const realValues = new Float32Array(data.map(point => point.real));\r\n    const imagValues = new Float32Array(data.map(point => point.imag));\r\n\r\n    // Create a PeriodicWave\r\n    const wave = audioContext.createPeriodicWave(realValues, imagValues);\r\n\r\n    // Set the waveform and connect the oscillator\r\n    oscillator.setPeriodicWave(wave);\r\n    oscillator.connect(audioContext.destination);\r\n\r\n    // Set frequency\r\n    oscillator.frequency.value = frequency\r\n\r\n    // Start the oscillator\r\n    oscillator.start();\r\n}\r\n\r\n\r\n\r\n/**\r\n * Stop the sound and release resources.\r\n */\r\nexport function stopSound() {\r\n    if (oscillator) {\r\n        oscillator.stop();\r\n        oscillator.disconnect();\r\n        oscillator = null;\r\n    }\r\n\r\n    if (audioContext) {\r\n        audioContext.close();\r\n        audioContext = null;\r\n    }\r\n}\r\n\r\nfunction normalizeWaveform(data: { index: number; value: number }[]): Float32Array {\r\n    const values = data.map((d) => d.value);\r\n    const max = Math.max(...values);\r\n    const min = Math.min(...values);\r\n    return Float32Array.from(values.map((v) => 2 * (v - min) / (max - min) - 1)); // Normierung auf [-1, 1]\r\n  }\r\n  \r\n\r\n\r\n/*\r\n\r\nFalls dein Array keine periodische Wellenform darstellt oder du es direkt ohne Interpolation abspielen m\u00F6chtest, kannst du stattdessen einen AudioBuffer verwenden. Dies erzeugt einen einzelnen Klang und ist keine kontinuierliche Schwingung:\r\nconst data = [\r\n  { index: 0, value: 0 },\r\n  { index: 1, value: 0.5 },\r\n  { index: 2, value: 1 },\r\n  { index: 3, value: 0.5 },\r\n  { index: 4, value: 0 },\r\n  { index: 5, value: -0.5 },\r\n  { index: 6, value: -1 },\r\n  { index: 7, value: -0.5 },\r\n]; // Beispiel einer Wellenform\r\n\r\ncreateOscillatorFromWaveform(data).catch((err) => console.error(err));\r\n\r\nasync function playWaveform(data: { index: number; value: number }[], sampleRate = 44100) {\r\n  const audioContext = new AudioContext();\r\n\r\n  // Normalisiere die Wellenform\r\n  const normalizedWaveform = normalizeWaveform(data);\r\n\r\n  // Erstelle einen AudioBuffer\r\n  const buffer = audioContext.createBuffer(1, normalizedWaveform.length, sampleRate);\r\n  const channelData = buffer.getChannelData(0);\r\n  channelData.set(normalizedWaveform);\r\n\r\n  // AudioBufferSourceNode erstellen\r\n  const source = audioContext.createBufferSource();\r\n  source.buffer = buffer;\r\n  source.connect(audioContext.destination);\r\n\r\n  // Abspielen\r\n  source.start();\r\n}\r\n*/", "import { Complex, add, scale, rotate } from \"./library\"\r\n\r\nexport class MandelbrotOutline{\r\n\r\nprivate _iterationDepth: number\r\nboundaryPoints: {real: number, imag:number}[] = []\r\n\r\nconstructor(iterationDepth: number){\r\n    this._iterationDepth = iterationDepth\r\n}\r\n\r\nset iterationDepth(n: number){\r\n    this._iterationDepth = n\r\n}\r\n\r\nget iterationDepth(): number{\r\n    return this._iterationDepth\r\n}\r\n\r\ncalcMandelbrotOutline(): Complex[]{\r\n    \r\n    const begin = Date.now()\r\n    let duration: number\r\n\r\n    this.boundaryPoints=[]\r\n    \r\n    // start from the well known left tip of the mandelbrot-set\r\n    const startPoint = {real: -2, imag:0}\r\n    \r\n    //step slightly out of the mandelbrotset at samplingRate/2 step\r\n    let directionVector = {real: -1, imag: 0}\r\n    const sampleLength = .1/Math.pow(this.iterationDepth,3)\r\n    const sampleAngle = Math.PI/8\r\n    let actualPoint = add(startPoint, scale(directionVector, sampleLength/2))\r\n    \r\n    console.log(\"sampleLength: \"+sampleLength+\" at iterationDepth: \"+this.iterationDepth)\r\n    \r\n    this.boundaryPoints.push(actualPoint)\r\n    \r\n    // then move upwards from here on\r\n    directionVector = {real: 0, imag: 1}\r\n\r\n    //move around half a time\r\n    while (actualPoint.imag >= 0){\r\n    \r\n        // test if actualPoint + directionVector/2 is inside the Mandelbrot\r\n        // if(mandelbrot(add(actualPoint, scale(directionVector, sampleLength/2)))){\r\n        //     // adjust by rotating the directionvector away from the set\r\n        //     directionVector = rotate(directionVector, sampleAngle)\r\n        // }\r\n        // cover the case, where we pierce into the set\r\n        if(this.mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n            directionVector = rotate(directionVector, .5 * sampleAngle)\r\n                \r\n            while (this.mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n           \r\n                // adjust by rotating the directionvector away from the set\r\n                directionVector = rotate(directionVector, .5 * sampleAngle)\r\n                    \r\n            }\r\n            const endpoint = add(actualPoint, scale(directionVector, sampleLength))\r\n            actualPoint = endpoint\r\n            \r\n            this.boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n        \r\n    \r\n        // cover the case, where we do not pierce into the set\r\n        if(!this.mandelbrot(add(actualPoint, scale(directionVector, sampleLength)))){\r\n        // test if actualPoint + directionVector/2 is inside the Mandelbrot\r\n            if(this.mandelbrot(add(actualPoint, scale(directionVector, sampleLength/2)))){\r\n                // adjust by rotating the directionvector away from the set\r\n                console.log(\"actualPoint + directionVector is not, but actualPoint + directionVector/2 is inside the Mandelbrot\")\r\n                directionVector = rotate(directionVector, 2*sampleAngle)\r\n            }\r\n            while(!this.mandelbrot(add(actualPoint, scale(directionVector, sampleLength))))    {\r\n                \r\n                //rotate the other way around towards the set\r\n                directionVector = rotate(directionVector, -.5*sampleAngle)\r\n            }\r\n            // then rotate away from the set to get out of the set again\r\n            directionVector = rotate(directionVector, .5*sampleAngle)\r\n\r\n            const endpoint = add(actualPoint, scale(directionVector, sampleLength))\r\n\r\n            actualPoint = endpoint\r\n            this.boundaryPoints.push(actualPoint)\r\n            \r\n        }\r\n    \r\n    }\r\n        \r\n    console.log(\"boundaryPoints.length: \"+this.boundaryPoints.length)\r\n    duration = Date.now() - begin\r\n    console.log(`sampling duration: ${duration} ms`)\r\n\r\n    return this.boundaryPoints\r\n}\r\n\r\n\r\n\r\n\r\nmandelbrot(c: {real: number, imag: number}): boolean{\r\n    let z = { real: c.real, imag: c.imag };\r\n    let iterations = 0;\r\n    while((iterations < this.iterationDepth) && (z.real * z.real + z.imag * z.imag) <= 4){\r\n        let realTemp  = z.real * z.real - z.imag * z.imag + c.real\r\n        z.imag = 2 * z.real * z.imag + c.imag\r\n        z.real = realTemp\r\n        \r\n        iterations ++\r\n        if(iterations == this.iterationDepth){\r\n            return true\r\n        }\r\n        \r\n    }\r\n    return false\r\n}\r\n}\r\n/*\r\n                setTimeout in Schleifen:\r\n\r\nsetTimeout f\u00FChrt den angegebenen Callback asynchron aus. Dadurch wird der Inhalt von setTimeout nicht blockierend ausgef\u00FChrt, sondern in die Warteschlange (Event Loop) gestellt. Das kann zu unerwartetem Verhalten f\u00FChren, insbesondere wenn die Schleife schnell durchl\u00E4uft.\r\nDa die Schleife nicht wartet, bis der setTimeout-Callback ausgef\u00FChrt wurde, k\u00F6nnen Werte von Variablen wie directionVector oder actualPoint zwischenzeitlich weiter ver\u00E4ndert werden, was zu falschen Ergebnissen f\u00FChren kann.\r\n         */", "\r\nconsole.log(\"ver 2220\")\r\nimport WorkerURL from './waveformworker.ts?worker';\r\nimport { MandelbrotOutline } from \"./calcMandelbrotOutline.js\";\r\nimport { Complex, drawLines, drawDots, pixelHeight, mirrorX, dft, idft, extractValuesAsFloat32Array, storage, createOscillatorFromWaveform, stopSound} from \"./library.js\";\r\n\r\n\r\nconst wrapper = document.getElementById(\"wrapper\")\r\nlet audioContext: AudioContext | null = null\r\nlet oscillator: OscillatorNode | null = null\r\n\r\nexport const rawDataSvgWidth =480\r\nexport const rawDataSvgHeight = 420\r\nconst dftSvgWidth = 480\r\nconst dftSvgHeight = 420\r\nconst idftSvgWidth = 480\r\nconst idftSvgHeight = 420\r\n\r\nlet width = 2.5\r\nlet height = width\r\nlet iterationDepth = 4;  // initial iteration-depth\r\nlet accuracy = 169      //iniitial accuracy for inverse discrete fourier transformation\r\nexport let xMin = -2, xMax = xMin + width\r\nexport let yMin = -1.2, yMax = yMin + height\r\n\r\n\r\n// // outsource the calculations to a worker\r\n// const worker = new Worker('waveformWorker.js');\r\n// console.log(\"worker: \"+worker)\r\n// worker.postMessage( iterationDepth );\r\n// worker.onmessage = (event) => {\r\n//     console.log(\"Worker response:\", event.data);\r\n//     //renderWaveform(event.data.waveform);\r\n// };\r\n\r\nlet rawSample: Complex[] = []\r\nlet rawCurvePath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\")\r\nlet dftSample: Complex[] = []\r\nlet dftPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\") \r\n\r\nconst headline: HTMLHeadElement = document.createElement(\"h1\")\r\n\r\n// there is the constructed mandelbrot line in the left window\r\nexport const rawSampleSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nrawSampleSvg.setAttribute(\"id\", \"sampleCurveSvg\")\r\nrawSampleSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\nrawSampleSvg.setAttribute(\"width\", `${rawDataSvgWidth}px`)\r\nrawSampleSvg.setAttribute(\"height\", `${rawDataSvgHeight}px`)\r\n\r\n// and there is the place where the transformed sampleCurve is plotted\r\nconst dftSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\ndftSvg.setAttribute(\"id\", \"dftSvg\")\r\ndftSvg.setAttribute(\"width\", `${dftSvgWidth}`)\r\ndftSvg.setAttribute(\"height\", `${dftSvgHeight}`)\r\ndftSvg.setAttribute(\"viewBox\", \"-0.000003941525533301985 -0.000004073599120061317 0.000007750550196828558 0.000007750550196828558\")\r\n\r\nconst idftSvg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\r\nidftSvg.setAttribute(\"id\", \"idftSvg\")\r\nidftSvg.setAttribute(\"width\", `${idftSvgWidth}`)\r\nidftSvg.setAttribute(\"height\", `${idftSvgHeight}`)\r\nidftSvg.setAttribute(\"viewBox\", \"-1.9 -1.25 2.5 2.5\")\r\n\r\n\r\nconst viewControlsContainer = document.createElement(\"div\")\r\nviewControlsContainer.id = \"viewControlsContainer\"\r\nviewControlsContainer.style.border = \"1px solid black\"\r\nviewControlsContainer.style.padding = \"10px\"\r\n\r\nconst viewElementsContainer = document.createElement(\"div\")\r\nviewElementsContainer.id = \"viewElementsContainer\"\r\nviewElementsContainer.style.border = \"1px solid black\"\r\nviewElementsContainer.style.padding = \"10px\"\r\n\r\nconst soundControlsContainer = document.createElement(\"div\")\r\nsoundControlsContainer.id = \"soundControlsContainer\"\r\nsoundControlsContainer.style.border = \"1px solid black\"\r\nsoundControlsContainer.style.padding = \"10px\"\r\n\r\nconst mandelbrotOutline = new MandelbrotOutline(iterationDepth)\r\nupdateHeadline()\r\nrawSample = mirrorX(mandelbrotOutline.calcMandelbrotOutline())\r\nconst rawLines = drawLines(rawSample)\r\n\r\ndftSample = dft(rawSample)\r\nconst dftDots = drawDots(dftSample, pixelHeight(dftSvg))\r\nlet idftSample = idft(dftSample, accuracy)\r\nstorage.set(iterationDepth, {rawSample: rawSample, rawLines: rawLines, dftSample: dftSample, dftDots: dftDots})\r\n\r\nconst soundButton = document.createElement(\"button\")\r\nsoundButton.innerHTML = \"oscillate boundary points\"\r\nsoundButton.style.width = \"200px\"\r\nlet isPlaying = false\r\n\r\nsoundButton.addEventListener(\"click\", ()=>{\r\n    if(!audioContext){\r\n        audioContext = new AudioContext()\r\n    }\r\n    if(!oscillator){\r\n        oscillator = audioContext.createOscillator()\r\n    }\r\n    if(!isPlaying){\r\n        soundButton.textContent = \"stop sound\"\r\n        console.log(sampleSelector.value)\r\n        let sample\r\n        if (sampleSelector.value == \"dft\")\r\n            sample = dftSample\r\n        else    \r\n        sample = rawSample\r\n    \r\n    const wave = audioContext.createPeriodicWave(extractValuesAsFloat32Array(sample, \"imag\"), \r\n    extractValuesAsFloat32Array(sample, \"real\")\r\n)\r\noscillator.setPeriodicWave(wave)\r\noscillator.connect(audioContext.destination)\r\noscillator.frequency.value = parseInt(frequencySlider.value)\r\noscillator.start()\r\n}\r\n\r\nif(isPlaying){\r\n    if (oscillator) {\r\n        oscillator.stop();\r\n        oscillator.disconnect();\r\n        oscillator = null;\r\n    }\r\n    \r\n    if (audioContext) {\r\n        audioContext.close();\r\n        audioContext = null;\r\n    }\r\n    soundButton.textContent = \"oscillate boundary points\"\r\n}\r\nisPlaying = !isPlaying\r\n\r\n})\r\n\r\n// control of the frequency\r\nconst frequencySliderLabel = document.createElement(\"label\")\r\nfrequencySliderLabel.setAttribute(\"for\", \"frequencySlider\")\r\nfrequencySliderLabel.innerHTML = \" frequency: \"\r\nconst frequencySlider = document.createElement(\"input\")\r\nfrequencySlider.id = \"frequencySlider\"\r\nfrequencySlider.type = \"range\"\r\nfrequencySlider.min = \"1\"\r\nfrequencySlider.max = \"440\"\r\nfrequencySlider.value = \"1\"\r\n\r\nfrequencySlider.addEventListener(\"input\", (event) => {\r\n    const frequency = (event.target as HTMLInputElement).valueAsNumber;\r\n    if(oscillator)\r\n        oscillator.frequency.value = frequency; \r\n});\r\n\r\n// control of the retransformation accuracy\r\nconst accuracySliderLabel = document.createElement(\"label\")\r\naccuracySliderLabel.setAttribute(\"for\", \"accuracySliderLabel\")\r\naccuracySliderLabel.innerHTML = \"accuracy: \"\r\nconst accuracySlider = document.createElement(\"input\")\r\naccuracySlider.id = \"accuracySlider\"\r\naccuracySlider.type = \"range\"\r\naccuracySlider.min = \"1\"\r\naccuracySlider.max = `${rawSample.length}`\r\naccuracySlider.value = \"169\"\r\n\r\naccuracySlider.addEventListener(\"input\", (event) => {\r\n    accuracy = (event.target as HTMLInputElement).valueAsNumber;\r\n    idftSample = idft(dftSample, accuracy)\r\n    idftSvg.innerHTML = \"\"\r\n    idftSvg.appendChild(drawLines(idftSample))\r\n});\r\n\r\n//select the sample to play\r\nconst sampleSelector = document.createElement(\"select\")\r\nconst selectRawSample = document.createElement(\"option\")\r\nconst selectDFT = document.createElement(\"option\")\r\nselectRawSample.setAttribute(\"value\", \"RawSample\")\r\nselectRawSample.textContent = \"RawSample\"\r\nselectDFT.setAttribute(\"value\", \"dft\")\r\nselectDFT.setAttribute(\"selected\", \"true\")\r\nselectDFT.textContent = \"Fourier-transformed Data\"\r\n\r\nsampleSelector.appendChild(selectRawSample)\r\nsampleSelector.appendChild(selectDFT)\r\nsampleSelector.addEventListener(\"change\", ()=>{\r\n})\r\n\r\n// control-element for the iteration-depth\r\nconst iterationDepthSliderLabel = document.createElement(\"label\")\r\niterationDepthSliderLabel.setAttribute(\"for\", \"iterationDepthSlider\")\r\niterationDepthSliderLabel.innerHTML = \"iterations: \"\r\nconst iterationDepthSlider = document.createElement(\"input\")\r\niterationDepthSlider.id = \"iterationsSlider\"\r\niterationDepthSlider.type = \"range\"\r\niterationDepthSlider.min = \"3\"\r\niterationDepthSlider.max = `${iterationDepth}`\r\niterationDepthSlider.step = \"1\"\r\niterationDepthSlider.value = `${iterationDepth}`\r\niterationDepthSlider.addEventListener(\"input\", async function(event){\r\n    mandelbrotOutline.iterationDepth = Number(iterationDepthSlider.value)\r\n    iterationDepthInput.value = iterationDepthSlider.value\r\n    updateHeadline()\r\n    \r\n    const storedData = storage.get(mandelbrotOutline.iterationDepth);\r\n    if (storedData && storedData.rawSample) {\r\n        // Daten aus dem Speicher holen\r\n        rawSample = storedData.rawSample\r\n        rawSampleSvg.appendChild(storedData.rawLines)\r\n        dftSample = storedData.dftSample\r\n        console.log(`Loaded raw data for iteration depth ${mandelbrotOutline.iterationDepth}`);\r\n    } else { \r\n        \r\n        //Daten berechnen und in den Speicher laden \r\n        console.log(`Calculating data for iteration depth ${mandelbrotOutline.iterationDepth}...`);\r\n        const newRawData = await mirrorX(mandelbrotOutline.calcMandelbrotOutline())\r\n        const newRawLines = await drawLines(newRawData)\r\n        const newDftSample = await dft(newRawData)\r\n        const newDftDots = await drawDots(newDftSample, pixelHeight(dftSvg))\r\n\r\n        storage.set(mandelbrotOutline.iterationDepth, {rawSample: newRawData, \r\n                                                        rawLines: newRawLines, \r\n                                                        dftSample: newDftSample,\r\n                                                        dftDots: newDftDots });\r\n        rawSample = storage.get(iterationDepth)?.rawSample || []; // Fallback auf leeres Array\r\n        console.log(`Calculated and loaded raw data for iteration depth ${mandelbrotOutline.iterationDepth}`);\r\n    }\r\n\r\n    rawSampleSvg.innerHTML = \"\"\r\n    rawSampleSvg.appendChild(drawLines(rawSample))\r\n    \r\n    dftSample = dft(rawSample)\r\n    dftSvg.innerHTML = \"\"\r\n    dftSvg.appendChild(drawDots(dftSample, pixelHeight(dftSvg)))\r\n    /*\r\n    idftSample = idft(dftSample, accuracy)\r\n    idftSvg.innerHTML = \"\"\r\n    idftSvg.appendChild(drawLines(idftSample))\r\n    */\r\n})\r\n\r\nconst iterationDepthInput = document.createElement(\"input\")\r\niterationDepthInput.type = \"number\"\r\niterationDepthInput.id = \"iterationDepthInput\"\r\niterationDepthInput.value = iterationDepthSlider.value\r\niterationDepthInput.oninput = () =>{\r\n    // check if desired iterationDepth is already stored\r\n    iterationDepthSlider.max = iterationDepthInput.value\r\n    console.log(\"iterationDepthSlider.max: \"+iterationDepthSlider.max)\r\n}\r\n\r\nsoundControlsContainer.appendChild(soundButton)\r\nsoundControlsContainer.appendChild(frequencySliderLabel)\r\nsoundControlsContainer.appendChild(frequencySlider)\r\nsoundControlsContainer.appendChild(sampleSelector)\r\n\r\nviewControlsContainer.appendChild(iterationDepthSliderLabel)\r\nviewControlsContainer.appendChild(iterationDepthSlider)\r\nviewControlsContainer.appendChild(iterationDepthInput)\r\nviewControlsContainer.appendChild(accuracySliderLabel)\r\nviewControlsContainer.appendChild(accuracySlider)\r\n\r\nviewElementsContainer.appendChild(rawSampleSvg)\r\nviewElementsContainer.appendChild(dftSvg)\r\nviewElementsContainer.appendChild(idftSvg)\r\n\r\nwrapper?.appendChild(headline)\r\nwrapper?.appendChild(soundControlsContainer)\r\nwrapper?.appendChild(viewControlsContainer)\r\nwrapper?.appendChild(viewElementsContainer)\r\n\r\nrawCurvePath = drawLines(rawSample)\r\nrawSampleSvg.appendChild(rawCurvePath)\r\n\r\n\r\ndftPath = drawDots(dftSample, pixelHeight(dftSvg))\r\ndftSvg.appendChild(dftPath)\r\n\r\nlet idftPath = drawLines(idftSample)\r\nidftSvg.appendChild(idftPath)\r\n\r\nlet xOffset: number\r\nlet yOffset: number\r\nlet mousedown = false\r\n\r\n\r\nrawSampleSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(rawSampleSvg, event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\n\r\nrawSampleSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(rawSampleSvg, event);\r\n    xMin += xOffset - coords.x\r\n    yMin += yOffset - coords.y\r\n    rawSampleSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\n\r\nrawSampleSvg.addEventListener(\"mouseleave\", () => {\r\n    mousedown = false\r\n})\r\n\r\nrawSampleSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n})\r\n\r\nrawSampleSvg.addEventListener(\"wheel\", (event) =>{\r\n    \r\n    let deltaY = event.deltaY\r\n    const clientWidth = rawSampleSvg.getBoundingClientRect().width\r\n    const mouseX = event.x - rawSampleSvg.getBoundingClientRect().x\r\n    const clientHeight = rawSampleSvg.getBoundingClientRect().height\r\n    const mouseY = event.y - rawSampleSvg.getBoundingClientRect().y\r\n\r\n    if(Math.abs(deltaY) < 100){\r\n        if(deltaY <= 0)\r\n            deltaY -= 100\r\n        else\r\n            deltaY += 100\r\n    }\r\n    const oldWidth = width\r\n    const oldHeight = height\r\n    width += width * 10 / deltaY \r\n    height = width\r\n    \r\n    xMin -= (width - oldWidth) * mouseX / clientWidth \r\n    xMax = xMin + width\r\n    yMin -=(height - oldHeight) * mouseY / clientHeight \r\n    yMax = yMin + height\r\n\r\n    rawSampleSvg.setAttribute(\"viewBox\", `${xMin} ${yMin} ${width} ${height}`)\r\n    \r\n})\r\n\r\ndftSvg.addEventListener(\"mouseleave\", () => {\r\n    mousedown = false\r\n})\r\ndftSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(dftSvg, event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\ndftSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(dftSvg, event);\r\n    let x = dftSvg.viewBox.baseVal.x\r\n    let y = dftSvg.viewBox.baseVal.y\r\n    let width = dftSvg.viewBox.baseVal.width\r\n    let height = dftSvg.viewBox.baseVal.height\r\n    x += xOffset - coords.x\r\n    y += yOffset - coords.y\r\n    dftSvg.setAttribute(\"viewBox\", `${x} ${y} ${width} ${height}`)\r\n})\r\n\r\ndftSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    \r\n})\r\ndftSvg.addEventListener(\"wheel\", (event) =>{\r\n    const clientWidth = dftSvg.getBoundingClientRect().width\r\n    const mouseX = event.x - dftSvg.getBoundingClientRect().x\r\n    const clientHeight = dftSvg.getBoundingClientRect().height\r\n    const mouseY = event.y - dftSvg.getBoundingClientRect().y\r\n    const oldWidth = dftSvg.viewBox.baseVal.width\r\n    const oldHeight = dftSvg.viewBox.baseVal.height\r\n    let x = dftSvg.viewBox.baseVal.x\r\n    let y = dftSvg.viewBox.baseVal.y\r\n    let width: number = oldWidth\r\n    let height: number = oldHeight\r\n\r\n    // differentiate between mousewheel and touchpad\r\n    let deltaY = event.deltaY\r\n    if(Math.abs(deltaY) < 100){\r\n        if(deltaY <= 0)\r\n            deltaY -= 100\r\n        else\r\n            deltaY += 100\r\n    }\r\n       \r\n    width += oldWidth * 10 / deltaY \r\n    height = width\r\n    \r\n    x -= (width - oldWidth) * mouseX / clientWidth \r\n    y -=(height - oldHeight) * mouseY / clientHeight \r\n    \r\n    dftSvg.setAttribute(\"viewBox\", `${x} ${y} ${width} ${height}`)\r\n  \r\n})\r\n\r\nidftSvg.addEventListener(\"mousedown\", (event) =>{\r\n    mousedown = true\r\n    const coords = getSvgCoords(dftSvg, event);\r\n    xOffset = coords.x;\r\n    yOffset = coords.y;\r\n})\r\n\r\nidftSvg.addEventListener(\"mouseleave\", () =>{\r\n    mousedown = false\r\n})\r\n\r\nidftSvg.addEventListener(\"mousemove\", (event) =>{\r\n    if(!mousedown)\r\n        return\r\n    const coords = getSvgCoords(idftSvg, event);\r\n    let x = idftSvg.viewBox.baseVal.x\r\n    let y = idftSvg.viewBox.baseVal.y\r\n    const width = idftSvg.viewBox.baseVal.width\r\n    const height = idftSvg.viewBox.baseVal.height\r\n    x += xOffset - coords.x\r\n    y += yOffset - coords.y\r\n    idftSvg.setAttribute(\"viewBox\", `${x} ${y} ${width} ${height}`)\r\n})\r\nidftSvg.addEventListener(\"mouseup\", ()=>{\r\n    mousedown = false\r\n    \r\n})\r\nidftSvg.addEventListener(\"wheel\", (event) =>{\r\n    const clientWidth = idftSvg.getBoundingClientRect().width\r\n    const mouseX = event.x - idftSvg.getBoundingClientRect().x\r\n    const clientHeight = idftSvg.getBoundingClientRect().height\r\n    const mouseY = event.y - idftSvg.getBoundingClientRect().y\r\n    const oldWidth = idftSvg.viewBox.baseVal.width\r\n    const oldHeight = idftSvg.viewBox.baseVal.height\r\n    let width = oldWidth\r\n    let height = oldHeight\r\n    let x = idftSvg.viewBox.baseVal.x\r\n    let y = idftSvg.viewBox.baseVal.y\r\n\r\n    // differentiate between mousewheel and touchpad\r\n    let deltaY = event.deltaY\r\n    if(Math.abs(deltaY) < 100){\r\n        if(deltaY <= 0)\r\n            deltaY -= 100\r\n        else\r\n            deltaY += 100\r\n    }\r\n    \r\n    width += width * 10 / deltaY \r\n    height = width\r\n    \r\n    x -= (width - oldWidth ) * mouseX / clientWidth\r\n    y -= (height - oldHeight) * mouseY / clientHeight\r\n    \r\n    idftSvg.setAttribute(\"viewBox\", `${x} ${y} ${width} ${height}`)\r\n    \r\n})\r\n\r\n\r\n// Outsource to library\r\n// Helper to get SVG coordinates\r\nfunction getSvgCoords(svgElement: SVGSVGElement, event: MouseEvent) {\r\n    const point = svgElement.createSVGPoint();\r\n    point.x = event.clientX;\r\n    point.y = event.clientY;\r\n    const svgCoords = point.matrixTransform(svgElement.getScreenCTM()!.inverse());\r\n    return svgCoords; \r\n}\r\n\r\n\r\n\r\n\r\nfunction drawExtrapolatedCurve(points: {index: number, value: number}[]): SVGPathElement{\r\n    \r\n    // Skalierung f\u00FCr die X- und Y-Koordinaten basierend auf `i` und `real`-Werten\r\n    const width = dftSvgWidth\r\n    const height = dftSvgHeight\r\n    const xScale = width / (points.length - 1); // Breite durch Anzahl der Punkte\r\n    const yMin = Math.min(...points.map(p => p.value));\r\n    const yMax = Math.max(...points.map(p => p.value));\r\n    const yScale = height / (yMax - yMin);\r\n\r\n    // Erzeuge die \"d\"-Attribute f\u00FCr das <path>-Element\r\n    let pathData = `M 0 ${height - (points[0].value - yMin) * yScale}`;\r\n    for (let j = 1; j < points.length; j++) {\r\n        const x = j * xScale;\r\n        const y = height - (points[j].value - yMin) * yScale;\r\n        pathData += ` L ${x} ${y}`;\r\n    }\r\n    \r\n\r\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"id\", \"extrapolatedCurve\")\r\n    path.setAttribute(\"d\", pathData);\r\n    path.setAttribute(\"fill\", \"none\");\r\n    path.setAttribute(\"stroke\", \"blue\");\r\n    path.setAttribute(\"stroke-width\", \"2\");\r\n    return (path);\r\n}\r\n\r\nfunction updateHeadline(){\r\n    headline.innerHTML = headline.innerHTML = `Sonification of the Mandelbrot-set at iteration-depth ${mandelbrotOutline.iterationDepth}`\r\n}"],
  "mappings": ";;;;;;;AAgBO,MAAM,UAAsC,oBAAI,IAAI;AAsCpD,WAAS,QAAQ,cAAmC;AACzD,UAAM,cAAc,aAAa;AACjC,UAAM,iBAAiB,CAAC,GAAG,YAAY;AACnC,aAAU,QAAQ,cAAc,GAAG,SAAS,GAAG,SAAQ;AACnD,YAAM,gBAAgB,EAAC,MAAM,aAAa,KAAK,EAAE,MAAM,MAAM,CAAC,aAAa,KAAK,EAAE,KAAI;AACtF,qBAAe,KAAK,aAAa;AAAA,IACrC;AACA,WAAO;AAAA,EACb;AAEO,WAAS,OAAO,QAAsC,eAAoD;AAC/G,UAAM,eAAe,KAAK,KAAK,KAAK,IAAI,OAAO,MAAK,CAAC,IAAG,KAAK,IAAI,OAAO,MAAK,CAAC,CAAC;AAC/E,UAAM,cAAc,KAAK,MAAM,OAAO,MAAM,OAAO,IAAI;AACvD,UAAM,mBAAmB,cAAc;AACvC,UAAM,gBAAgB,MAAM,EAAC,MAAM,KAAK,IAAI,gBAAgB,GAAG,MAAM,KAAK,IAAI,gBAAgB,EAAC,GAAG,YAAY;AAC9G,WAAO;AAAA,EACT;AAEO,WAAS,MAAM,QAAsC,QAA6C;AACvG,WAAO,EAAC,MAAM,OAAO,OAAO,QAAQ,MAAM,OAAO,OAAO,OAAM;AAAA,EAChE;AAEO,WAAS,IAAI,IAAkC,IAA+D;AACnH,WAAO,EAAC,MAAM,GAAG,OAAO,GAAG,MAAM,MAAM,GAAG,OAAO,GAAG,KAAI;AAAA,EAC1D;AAIO,WAAS,IAAI,MAA4B;AAC9C,UAAM,IAAI,KAAK;AACf,UAAM,SAAoB,CAAC;AAE3B,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAI,MAAe,EAAE,MAAM,GAAG,MAAM,EAAE;AAEtC,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,cAAM,QAAS,IAAI,KAAK,KAAK,IAAI,IAAK;AACtC,cAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,cAAM,MAAM,KAAK,IAAI,KAAK;AAE1B,YAAI,QAAQ,KAAK,CAAC,EAAE,OAAO,MAAM,KAAK,CAAC,EAAE,OAAO;AAChD,YAAI,QAAQ,KAAK,CAAC,EAAE,OAAO,MAAM,KAAK,CAAC,EAAE,OAAO;AAAA,MAClD;AAGA,UAAI,QAAQ;AACZ,UAAI,QAAQ;AAEZ,aAAO,KAAK,GAAG;AAAA,IACjB;AAEA,WAAO;AAAA,EACT;AAGO,WAAS,KAAK,cAAyB,GAAsB;AAClE,UAAM,SAAoB,CAAC;AAE3B,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAI,MAAe,EAAE,MAAM,GAAG,MAAM,EAAE;AAEtC,eAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAM,QAAS,IAAI,KAAK,KAAK,IAAI,IAAK;AACtC,cAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,cAAM,MAAM,KAAK,IAAI,KAAK;AAE1B,YAAI,QAAQ,aAAa,CAAC,EAAE,OAAO,MAAM,aAAa,CAAC,EAAE,OAAO;AAChE,YAAI,QAAQ,aAAa,CAAC,EAAE,OAAO,MAAM,aAAa,CAAC,EAAE,OAAO;AAAA,MAClE;AAEA,aAAO,KAAK,GAAG;AAAA,IACjB;AAEA,WAAO;AAAA,EACT;AAEO,WAAS,UAAU,cAAyC;AACjE,UAAM,kBAAkB,SAAS,gBAAgB,8BAA8B,MAAM;AAErF,QAAG,aAAa,SAAS,GAAE;AACvB,cAAQ,KAAK,iCAAiC;AAC9C,aAAO;AAAA,IACX;AAEA,QAAI,WAAW,IAAI,aAAa,CAAC,EAAE,IAAI,IAAI,aAAa,CAAC,EAAE,IAAI;AAC/D,aAAQ,IAAI,GAAG,IAAE,aAAa,QAAQ,KAAI;AACtC,kBAAY,KAAK,aAAa,CAAC,EAAE,IAAI,IAAI,aAAa,CAAC,EAAE,IAAI;AAAA,IACjE;AAEA,oBAAgB,aAAa,MAAM,aAAa;AAChD,oBAAgB,aAAa,QAAQ,MAAM;AAC3C,oBAAgB,aAAa,UAAU,OAAO;AAC9C,oBAAgB,aAAa,gBAAgB,OAAO;AACpD,oBAAgB,aAAa,iBAAiB,oBAAoB;AAClE,oBAAgB,aAAa,KAAK,GAAG,QAAQ,EAAE;AAE/C,WAAO;AAAA,EACT;AAEO,WAAS,YAAY,SAA+B;AAEzD,WAAO,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,sBAAsB,EAAE;AAAA,EAC1E;AAEO,WAAS,SAAS,cAAyBA,cAAqC;AACrF,UAAM,kBAAkB,SAAS,gBAAgB,8BAA8B,MAAM;AACrF,UAAM,cAAc;AAEpB,YAAQ,IAAIA,YAAW;AAEvB,QAAI,WAAW;AACf,aAAQ,IAAI,GAAG,IAAE,aAAa,QAAQ,KAAI;AACtC,kBAAY,KAAK,aAAa,CAAC,EAAE,IAAI,IAAI,aAAa,CAAC,EAAE,IAAI,MAAMA,YAAW;AAAA,IAClF;AACA,oBAAgB,aAAa,MAAM,aAAa;AAChD,oBAAgB,aAAa,QAAQ,MAAM;AAC3C,oBAAgB,aAAa,UAAU,OAAO;AAC9C,oBAAgB,aAAa,gBAAgB,GAAG,WAAW,EAAE;AAC7D,oBAAgB,aAAa,iBAAiB,oBAAoB;AAClE,oBAAgB,aAAa,KAAK,GAAG,QAAQ,EAAE;AAE/C,WAAO;AAAA,EACT;AAaS,WAAS,4BACd,QACA,MACc;AACd,WAAO,IAAI,aAAa,OAAO,IAAI,CAAC,YAAY,QAAQ,IAAI,CAAC,CAAC;AAAA,EAChE;;;AChMK,MAAM,oBAAN,MAAuB;AAAA,IAK9B,YAAYC,iBAAuB;AAHnC,0BAAQ;AACR,4CAAgD,CAAC;AAG7C,WAAK,kBAAkBA;AAAA,IAC3B;AAAA,IAEA,IAAI,eAAe,GAAU;AACzB,WAAK,kBAAkB;AAAA,IAC3B;AAAA,IAEA,IAAI,iBAAwB;AACxB,aAAO,KAAK;AAAA,IAChB;AAAA,IAEA,wBAAkC;AAE9B,YAAM,QAAQ,KAAK,IAAI;AACvB,UAAI;AAEJ,WAAK,iBAAe,CAAC;AAGrB,YAAM,aAAa,EAAC,MAAM,IAAI,MAAK,EAAC;AAGpC,UAAI,kBAAkB,EAAC,MAAM,IAAI,MAAM,EAAC;AACxC,YAAM,eAAe,MAAG,KAAK,IAAI,KAAK,gBAAe,CAAC;AACtD,YAAM,cAAc,KAAK,KAAG;AAC5B,UAAI,cAAc,IAAI,YAAY,MAAM,iBAAiB,eAAa,CAAC,CAAC;AAExE,cAAQ,IAAI,mBAAiB,eAAa,yBAAuB,KAAK,cAAc;AAEpF,WAAK,eAAe,KAAK,WAAW;AAGpC,wBAAkB,EAAC,MAAM,GAAG,MAAM,EAAC;AAGnC,aAAO,YAAY,QAAQ,GAAE;AAQzB,YAAG,KAAK,WAAW,IAAI,aAAa,MAAM,iBAAiB,YAAY,CAAC,CAAC,GAAE;AACvE,4BAAkB,OAAO,iBAAiB,MAAK,WAAW;AAE1D,iBAAO,KAAK,WAAW,IAAI,aAAa,MAAM,iBAAiB,YAAY,CAAC,CAAC,GAAE;AAG3E,8BAAkB,OAAO,iBAAiB,MAAK,WAAW;AAAA,UAE9D;AACA,gBAAM,WAAW,IAAI,aAAa,MAAM,iBAAiB,YAAY,CAAC;AACtE,wBAAc;AAEd,eAAK,eAAe,KAAK,WAAW;AAAA,QAExC;AAIA,YAAG,CAAC,KAAK,WAAW,IAAI,aAAa,MAAM,iBAAiB,YAAY,CAAC,CAAC,GAAE;AAExE,cAAG,KAAK,WAAW,IAAI,aAAa,MAAM,iBAAiB,eAAa,CAAC,CAAC,CAAC,GAAE;AAEzE,oBAAQ,IAAI,oGAAoG;AAChH,8BAAkB,OAAO,iBAAiB,IAAE,WAAW;AAAA,UAC3D;AACA,iBAAM,CAAC,KAAK,WAAW,IAAI,aAAa,MAAM,iBAAiB,YAAY,CAAC,CAAC,GAAM;AAG/E,8BAAkB,OAAO,iBAAiB,OAAI,WAAW;AAAA,UAC7D;AAEA,4BAAkB,OAAO,iBAAiB,MAAG,WAAW;AAExD,gBAAM,WAAW,IAAI,aAAa,MAAM,iBAAiB,YAAY,CAAC;AAEtE,wBAAc;AACd,eAAK,eAAe,KAAK,WAAW;AAAA,QAExC;AAAA,MAEJ;AAEA,cAAQ,IAAI,4BAA0B,KAAK,eAAe,MAAM;AAChE,iBAAW,KAAK,IAAI,IAAI;AACxB,cAAQ,IAAI,sBAAsB,QAAQ,KAAK;AAE/C,aAAO,KAAK;AAAA,IAChB;AAAA,IAKA,WAAW,GAAyC;AAChD,UAAI,IAAI,EAAE,MAAM,EAAE,MAAM,MAAM,EAAE,KAAK;AACrC,UAAI,aAAa;AACjB,aAAO,aAAa,KAAK,kBAAoB,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,QAAS,GAAE;AACjF,YAAI,WAAY,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE;AACtD,UAAE,OAAO,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;AACjC,UAAE,OAAO;AAET;AACA,YAAG,cAAc,KAAK,gBAAe;AACjC,iBAAO;AAAA,QACX;AAAA,MAEJ;AACA,aAAO;AAAA,IACX;AAAA,EACA;;;ACtHA,UAAQ,IAAI,UAAU;AAMtB,MAAM,UAAU,SAAS,eAAe,SAAS;AACjD,MAAI,eAAoC;AACxC,MAAI,aAAoC;AAEjC,MAAM,kBAAiB;AACvB,MAAM,mBAAmB;AAChC,MAAM,cAAc;AACpB,MAAM,eAAe;AACrB,MAAM,eAAe;AACrB,MAAM,gBAAgB;AAEtB,MAAI,QAAQ;AACZ,MAAI,SAAS;AACb,MAAI,iBAAiB;AACrB,MAAI,WAAW;AACR,MAAI,OAAO;AAAX,MAAe,OAAO,OAAO;AAC7B,MAAI,OAAO;AAAX,MAAiB,OAAO,OAAO;AAYtC,MAAI,YAAuB,CAAC;AAC5B,MAAI,eAAe,SAAS,gBAAgB,8BAA8B,MAAM;AAChF,MAAI,YAAuB,CAAC;AAC5B,MAAI,UAAU,SAAS,gBAAgB,8BAA8B,MAAM;AAE3E,MAAM,WAA4B,SAAS,cAAc,IAAI;AAGtD,MAAM,eAAe,SAAS,gBAAgB,8BAA8B,KAAK;AACxF,eAAa,aAAa,MAAM,gBAAgB;AAChD,eAAa,aAAa,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,MAAM,EAAE;AACzE,eAAa,aAAa,SAAS,GAAG,eAAe,IAAI;AACzD,eAAa,aAAa,UAAU,GAAG,gBAAgB,IAAI;AAG3D,MAAM,SAAS,SAAS,gBAAgB,8BAA8B,KAAK;AAC3E,SAAO,aAAa,MAAM,QAAQ;AAClC,SAAO,aAAa,SAAS,GAAG,WAAW,EAAE;AAC7C,SAAO,aAAa,UAAU,GAAG,YAAY,EAAE;AAC/C,SAAO,aAAa,WAAW,mGAAmG;AAElI,MAAM,UAAU,SAAS,gBAAgB,8BAA8B,KAAK;AAC5E,UAAQ,aAAa,MAAM,SAAS;AACpC,UAAQ,aAAa,SAAS,GAAG,YAAY,EAAE;AAC/C,UAAQ,aAAa,UAAU,GAAG,aAAa,EAAE;AACjD,UAAQ,aAAa,WAAW,oBAAoB;AAGpD,MAAM,wBAAwB,SAAS,cAAc,KAAK;AAC1D,wBAAsB,KAAK;AAC3B,wBAAsB,MAAM,SAAS;AACrC,wBAAsB,MAAM,UAAU;AAEtC,MAAM,wBAAwB,SAAS,cAAc,KAAK;AAC1D,wBAAsB,KAAK;AAC3B,wBAAsB,MAAM,SAAS;AACrC,wBAAsB,MAAM,UAAU;AAEtC,MAAM,yBAAyB,SAAS,cAAc,KAAK;AAC3D,yBAAuB,KAAK;AAC5B,yBAAuB,MAAM,SAAS;AACtC,yBAAuB,MAAM,UAAU;AAEvC,MAAM,oBAAoB,IAAI,kBAAkB,cAAc;AAC9D,iBAAe;AACf,cAAY,QAAQ,kBAAkB,sBAAsB,CAAC;AAC7D,MAAM,WAAW,UAAU,SAAS;AAEpC,cAAY,IAAI,SAAS;AACzB,MAAM,UAAU,SAAS,WAAW,YAAY,MAAM,CAAC;AACvD,MAAI,aAAa,KAAK,WAAW,QAAQ;AACzC,UAAQ,IAAI,gBAAgB,EAAC,WAAsB,UAAoB,WAAsB,QAAgB,CAAC;AAE9G,MAAM,cAAc,SAAS,cAAc,QAAQ;AACnD,cAAY,YAAY;AACxB,cAAY,MAAM,QAAQ;AAC1B,MAAI,YAAY;AAEhB,cAAY,iBAAiB,SAAS,MAAI;AACtC,QAAG,CAAC,cAAa;AACb,qBAAe,IAAI,aAAa;AAAA,IACpC;AACA,QAAG,CAAC,YAAW;AACX,mBAAa,aAAa,iBAAiB;AAAA,IAC/C;AACA,QAAG,CAAC,WAAU;AACV,kBAAY,cAAc;AAC1B,cAAQ,IAAI,eAAe,KAAK;AAChC,UAAI;AACJ,UAAI,eAAe,SAAS;AACxB,iBAAS;AAAA;AAEb,iBAAS;AAEb,YAAM,OAAO,aAAa;AAAA,QAAmB,4BAA4B,QAAQ,MAAM;AAAA,QACvF,4BAA4B,QAAQ,MAAM;AAAA,MAC9C;AACA,iBAAW,gBAAgB,IAAI;AAC/B,iBAAW,QAAQ,aAAa,WAAW;AAC3C,iBAAW,UAAU,QAAQ,SAAS,gBAAgB,KAAK;AAC3D,iBAAW,MAAM;AAAA,IACjB;AAEA,QAAG,WAAU;AACT,UAAI,YAAY;AACZ,mBAAW,KAAK;AAChB,mBAAW,WAAW;AACtB,qBAAa;AAAA,MACjB;AAEA,UAAI,cAAc;AACd,qBAAa,MAAM;AACnB,uBAAe;AAAA,MACnB;AACA,kBAAY,cAAc;AAAA,IAC9B;AACA,gBAAY,CAAC;AAAA,EAEb,CAAC;AAGD,MAAM,uBAAuB,SAAS,cAAc,OAAO;AAC3D,uBAAqB,aAAa,OAAO,iBAAiB;AAC1D,uBAAqB,YAAY;AACjC,MAAM,kBAAkB,SAAS,cAAc,OAAO;AACtD,kBAAgB,KAAK;AACrB,kBAAgB,OAAO;AACvB,kBAAgB,MAAM;AACtB,kBAAgB,MAAM;AACtB,kBAAgB,QAAQ;AAExB,kBAAgB,iBAAiB,SAAS,CAAC,UAAU;AACjD,UAAM,YAAa,MAAM,OAA4B;AACrD,QAAG;AACC,iBAAW,UAAU,QAAQ;AAAA,EACrC,CAAC;AAGD,MAAM,sBAAsB,SAAS,cAAc,OAAO;AAC1D,sBAAoB,aAAa,OAAO,qBAAqB;AAC7D,sBAAoB,YAAY;AAChC,MAAM,iBAAiB,SAAS,cAAc,OAAO;AACrD,iBAAe,KAAK;AACpB,iBAAe,OAAO;AACtB,iBAAe,MAAM;AACrB,iBAAe,MAAM,GAAG,UAAU,MAAM;AACxC,iBAAe,QAAQ;AAEvB,iBAAe,iBAAiB,SAAS,CAAC,UAAU;AAChD,eAAY,MAAM,OAA4B;AAC9C,iBAAa,KAAK,WAAW,QAAQ;AACrC,YAAQ,YAAY;AACpB,YAAQ,YAAY,UAAU,UAAU,CAAC;AAAA,EAC7C,CAAC;AAGD,MAAM,iBAAiB,SAAS,cAAc,QAAQ;AACtD,MAAM,kBAAkB,SAAS,cAAc,QAAQ;AACvD,MAAM,YAAY,SAAS,cAAc,QAAQ;AACjD,kBAAgB,aAAa,SAAS,WAAW;AACjD,kBAAgB,cAAc;AAC9B,YAAU,aAAa,SAAS,KAAK;AACrC,YAAU,aAAa,YAAY,MAAM;AACzC,YAAU,cAAc;AAExB,iBAAe,YAAY,eAAe;AAC1C,iBAAe,YAAY,SAAS;AACpC,iBAAe,iBAAiB,UAAU,MAAI;AAAA,EAC9C,CAAC;AAGD,MAAM,4BAA4B,SAAS,cAAc,OAAO;AAChE,4BAA0B,aAAa,OAAO,sBAAsB;AACpE,4BAA0B,YAAY;AACtC,MAAM,uBAAuB,SAAS,cAAc,OAAO;AAC3D,uBAAqB,KAAK;AAC1B,uBAAqB,OAAO;AAC5B,uBAAqB,MAAM;AAC3B,uBAAqB,MAAM,GAAG,cAAc;AAC5C,uBAAqB,OAAO;AAC5B,uBAAqB,QAAQ,GAAG,cAAc;AAC9C,uBAAqB,iBAAiB,SAAS,eAAe,OAAM;AAChE,sBAAkB,iBAAiB,OAAO,qBAAqB,KAAK;AACpE,wBAAoB,QAAQ,qBAAqB;AACjD,mBAAe;AAEf,UAAM,aAAa,QAAQ,IAAI,kBAAkB,cAAc;AAC/D,QAAI,cAAc,WAAW,WAAW;AAEpC,kBAAY,WAAW;AACvB,mBAAa,YAAY,WAAW,QAAQ;AAC5C,kBAAY,WAAW;AACvB,cAAQ,IAAI,uCAAuC,kBAAkB,cAAc,EAAE;AAAA,IACzF,OAAO;AAGH,cAAQ,IAAI,wCAAwC,kBAAkB,cAAc,KAAK;AACzF,YAAM,aAAa,MAAM,QAAQ,kBAAkB,sBAAsB,CAAC;AAC1E,YAAM,cAAc,MAAM,UAAU,UAAU;AAC9C,YAAM,eAAe,MAAM,IAAI,UAAU;AACzC,YAAM,aAAa,MAAM,SAAS,cAAc,YAAY,MAAM,CAAC;AAEnE,cAAQ,IAAI,kBAAkB,gBAAgB;AAAA,QAAC,WAAW;AAAA,QACV,UAAU;AAAA,QACV,WAAW;AAAA,QACX,SAAS;AAAA,MAAW,CAAC;AACrE,kBAAY,QAAQ,IAAI,cAAc,GAAG,aAAa,CAAC;AACvD,cAAQ,IAAI,sDAAsD,kBAAkB,cAAc,EAAE;AAAA,IACxG;AAEA,iBAAa,YAAY;AACzB,iBAAa,YAAY,UAAU,SAAS,CAAC;AAE7C,gBAAY,IAAI,SAAS;AACzB,WAAO,YAAY;AACnB,WAAO,YAAY,SAAS,WAAW,YAAY,MAAM,CAAC,CAAC;AAAA,EAM/D,CAAC;AAED,MAAM,sBAAsB,SAAS,cAAc,OAAO;AAC1D,sBAAoB,OAAO;AAC3B,sBAAoB,KAAK;AACzB,sBAAoB,QAAQ,qBAAqB;AACjD,sBAAoB,UAAU,MAAK;AAE/B,yBAAqB,MAAM,oBAAoB;AAC/C,YAAQ,IAAI,+BAA6B,qBAAqB,GAAG;AAAA,EACrE;AAEA,yBAAuB,YAAY,WAAW;AAC9C,yBAAuB,YAAY,oBAAoB;AACvD,yBAAuB,YAAY,eAAe;AAClD,yBAAuB,YAAY,cAAc;AAEjD,wBAAsB,YAAY,yBAAyB;AAC3D,wBAAsB,YAAY,oBAAoB;AACtD,wBAAsB,YAAY,mBAAmB;AACrD,wBAAsB,YAAY,mBAAmB;AACrD,wBAAsB,YAAY,cAAc;AAEhD,wBAAsB,YAAY,YAAY;AAC9C,wBAAsB,YAAY,MAAM;AACxC,wBAAsB,YAAY,OAAO;AAEzC,WAAS,YAAY,QAAQ;AAC7B,WAAS,YAAY,sBAAsB;AAC3C,WAAS,YAAY,qBAAqB;AAC1C,WAAS,YAAY,qBAAqB;AAE1C,iBAAe,UAAU,SAAS;AAClC,eAAa,YAAY,YAAY;AAGrC,YAAU,SAAS,WAAW,YAAY,MAAM,CAAC;AACjD,SAAO,YAAY,OAAO;AAE1B,MAAI,WAAW,UAAU,UAAU;AACnC,UAAQ,YAAY,QAAQ;AAE5B,MAAI;AACJ,MAAI;AACJ,MAAI,YAAY;AAGhB,eAAa,iBAAiB,aAAa,CAAC,UAAS;AACjD,gBAAY;AACZ,UAAM,SAAS,aAAa,cAAc,KAAK;AAC/C,cAAU,OAAO;AACjB,cAAU,OAAO;AAAA,EACrB,CAAC;AAED,eAAa,iBAAiB,aAAa,CAAC,UAAS;AACjD,QAAG,CAAC;AACA;AACJ,UAAM,SAAS,aAAa,cAAc,KAAK;AAC/C,YAAQ,UAAU,OAAO;AACzB,YAAQ,UAAU,OAAO;AACzB,iBAAa,aAAa,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,MAAM,EAAE;AAAA,EAE7E,CAAC;AAED,eAAa,iBAAiB,cAAc,MAAM;AAC9C,gBAAY;AAAA,EAChB,CAAC;AAED,eAAa,iBAAiB,WAAW,MAAI;AACzC,gBAAY;AAAA,EAChB,CAAC;AAED,eAAa,iBAAiB,SAAS,CAAC,UAAS;AAE7C,QAAI,SAAS,MAAM;AACnB,UAAM,cAAc,aAAa,sBAAsB,EAAE;AACzD,UAAM,SAAS,MAAM,IAAI,aAAa,sBAAsB,EAAE;AAC9D,UAAM,eAAe,aAAa,sBAAsB,EAAE;AAC1D,UAAM,SAAS,MAAM,IAAI,aAAa,sBAAsB,EAAE;AAE9D,QAAG,KAAK,IAAI,MAAM,IAAI,KAAI;AACtB,UAAG,UAAU;AACT,kBAAU;AAAA;AAEV,kBAAU;AAAA,IAClB;AACA,UAAM,WAAW;AACjB,UAAM,YAAY;AAClB,aAAS,QAAQ,KAAK;AACtB,aAAS;AAET,aAAS,QAAQ,YAAY,SAAS;AACtC,WAAO,OAAO;AACd,aAAQ,SAAS,aAAa,SAAS;AACvC,WAAO,OAAO;AAEd,iBAAa,aAAa,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,MAAM,EAAE;AAAA,EAE7E,CAAC;AAED,SAAO,iBAAiB,cAAc,MAAM;AACxC,gBAAY;AAAA,EAChB,CAAC;AACD,SAAO,iBAAiB,aAAa,CAAC,UAAS;AAC3C,gBAAY;AACZ,UAAM,SAAS,aAAa,QAAQ,KAAK;AACzC,cAAU,OAAO;AACjB,cAAU,OAAO;AAAA,EACrB,CAAC;AACD,SAAO,iBAAiB,aAAa,CAAC,UAAS;AAC3C,QAAG,CAAC;AACA;AACJ,UAAM,SAAS,aAAa,QAAQ,KAAK;AACzC,QAAI,IAAI,OAAO,QAAQ,QAAQ;AAC/B,QAAI,IAAI,OAAO,QAAQ,QAAQ;AAC/B,QAAIC,SAAQ,OAAO,QAAQ,QAAQ;AACnC,QAAIC,UAAS,OAAO,QAAQ,QAAQ;AACpC,SAAK,UAAU,OAAO;AACtB,SAAK,UAAU,OAAO;AACtB,WAAO,aAAa,WAAW,GAAG,CAAC,IAAI,CAAC,IAAID,MAAK,IAAIC,OAAM,EAAE;AAAA,EACjE,CAAC;AAED,SAAO,iBAAiB,WAAW,MAAI;AACnC,gBAAY;AAAA,EAEhB,CAAC;AACD,SAAO,iBAAiB,SAAS,CAAC,UAAS;AACvC,UAAM,cAAc,OAAO,sBAAsB,EAAE;AACnD,UAAM,SAAS,MAAM,IAAI,OAAO,sBAAsB,EAAE;AACxD,UAAM,eAAe,OAAO,sBAAsB,EAAE;AACpD,UAAM,SAAS,MAAM,IAAI,OAAO,sBAAsB,EAAE;AACxD,UAAM,WAAW,OAAO,QAAQ,QAAQ;AACxC,UAAM,YAAY,OAAO,QAAQ,QAAQ;AACzC,QAAI,IAAI,OAAO,QAAQ,QAAQ;AAC/B,QAAI,IAAI,OAAO,QAAQ,QAAQ;AAC/B,QAAID,SAAgB;AACpB,QAAIC,UAAiB;AAGrB,QAAI,SAAS,MAAM;AACnB,QAAG,KAAK,IAAI,MAAM,IAAI,KAAI;AACtB,UAAG,UAAU;AACT,kBAAU;AAAA;AAEV,kBAAU;AAAA,IAClB;AAEA,IAAAD,UAAS,WAAW,KAAK;AACzB,IAAAC,UAASD;AAET,UAAMA,SAAQ,YAAY,SAAS;AACnC,UAAKC,UAAS,aAAa,SAAS;AAEpC,WAAO,aAAa,WAAW,GAAG,CAAC,IAAI,CAAC,IAAID,MAAK,IAAIC,OAAM,EAAE;AAAA,EAEjE,CAAC;AAED,UAAQ,iBAAiB,aAAa,CAAC,UAAS;AAC5C,gBAAY;AACZ,UAAM,SAAS,aAAa,QAAQ,KAAK;AACzC,cAAU,OAAO;AACjB,cAAU,OAAO;AAAA,EACrB,CAAC;AAED,UAAQ,iBAAiB,cAAc,MAAK;AACxC,gBAAY;AAAA,EAChB,CAAC;AAED,UAAQ,iBAAiB,aAAa,CAAC,UAAS;AAC5C,QAAG,CAAC;AACA;AACJ,UAAM,SAAS,aAAa,SAAS,KAAK;AAC1C,QAAI,IAAI,QAAQ,QAAQ,QAAQ;AAChC,QAAI,IAAI,QAAQ,QAAQ,QAAQ;AAChC,UAAMD,SAAQ,QAAQ,QAAQ,QAAQ;AACtC,UAAMC,UAAS,QAAQ,QAAQ,QAAQ;AACvC,SAAK,UAAU,OAAO;AACtB,SAAK,UAAU,OAAO;AACtB,YAAQ,aAAa,WAAW,GAAG,CAAC,IAAI,CAAC,IAAID,MAAK,IAAIC,OAAM,EAAE;AAAA,EAClE,CAAC;AACD,UAAQ,iBAAiB,WAAW,MAAI;AACpC,gBAAY;AAAA,EAEhB,CAAC;AACD,UAAQ,iBAAiB,SAAS,CAAC,UAAS;AACxC,UAAM,cAAc,QAAQ,sBAAsB,EAAE;AACpD,UAAM,SAAS,MAAM,IAAI,QAAQ,sBAAsB,EAAE;AACzD,UAAM,eAAe,QAAQ,sBAAsB,EAAE;AACrD,UAAM,SAAS,MAAM,IAAI,QAAQ,sBAAsB,EAAE;AACzD,UAAM,WAAW,QAAQ,QAAQ,QAAQ;AACzC,UAAM,YAAY,QAAQ,QAAQ,QAAQ;AAC1C,QAAID,SAAQ;AACZ,QAAIC,UAAS;AACb,QAAI,IAAI,QAAQ,QAAQ,QAAQ;AAChC,QAAI,IAAI,QAAQ,QAAQ,QAAQ;AAGhC,QAAI,SAAS,MAAM;AACnB,QAAG,KAAK,IAAI,MAAM,IAAI,KAAI;AACtB,UAAG,UAAU;AACT,kBAAU;AAAA;AAEV,kBAAU;AAAA,IAClB;AAEA,IAAAD,UAASA,SAAQ,KAAK;AACtB,IAAAC,UAASD;AAET,UAAMA,SAAQ,YAAa,SAAS;AACpC,UAAMC,UAAS,aAAa,SAAS;AAErC,YAAQ,aAAa,WAAW,GAAG,CAAC,IAAI,CAAC,IAAID,MAAK,IAAIC,OAAM,EAAE;AAAA,EAElE,CAAC;AAKD,WAAS,aAAa,YAA2B,OAAmB;AAChE,UAAM,QAAQ,WAAW,eAAe;AACxC,UAAM,IAAI,MAAM;AAChB,UAAM,IAAI,MAAM;AAChB,UAAM,YAAY,MAAM,gBAAgB,WAAW,aAAa,EAAG,QAAQ,CAAC;AAC5E,WAAO;AAAA,EACX;AAiCA,WAAS,iBAAgB;AACrB,aAAS,YAAY,SAAS,YAAY,yDAAyD,kBAAkB,cAAc;AAAA,EACvI;",
  "names": ["pixelHeight", "iterationDepth", "width", "height"]
}
